# ModuForge-RS å¤–éƒ¨é¡¹ç›®é›†æˆè§„åˆ™
# é€‚ç”¨äºå¼•å…¥ ModuForge-RS ä½œä¸ºæ ¸å¿ƒåº“çš„é¡¹ç›®

## é¡¹ç›®æ¦‚è§ˆ
è¿™ä¸ªé¡¹ç›®ä½¿ç”¨ ModuForge-RS ä½œä¸ºæ ¸å¿ƒçŠ¶æ€ç®¡ç†å’Œæ•°æ®è½¬æ¢æ¡†æ¶ã€‚ModuForge-RS æ˜¯ä¸€ä¸ªåŸºäº Rust çš„ä¸å¯å˜æ•°æ®ç»“æ„å’Œäº‹ä»¶é©±åŠ¨æ¶æ„çš„æ¡†æ¶ã€‚

## ModuForge-RS æ ¸å¿ƒä¾èµ–é…ç½®

### Cargo.toml ä¾èµ–é…ç½®
åœ¨ä½ çš„é¡¹ç›®ä¸­æ·»åŠ ä»¥ä¸‹ä¾èµ–ï¼š

```toml
[dependencies]
# ModuForge-RS æ ¸å¿ƒç»„ä»¶
moduforge-core = "0.4.8"
moduforge-model = "0.4.8"
moduforge-state = "0.4.8"
moduforge-transform = "0.4.8"
moduforge-rules-engine = "0.4.8"
moduforge-rules-expression = "0.4.8"
moduforge-collaboration = "0.4.8"
moduforge-template = "0.4.8"

# ModuForge-RS ä¾èµ–çš„æ ¸å¿ƒåº“
tokio = { version = "1.0", features = ["full"] }
serde = { version = "1.0", features = ["derive", "rc"] }
im = { version = "15.1", features = ["serde"] }
anyhow = "1"
thiserror = "2.0.12"
async-trait = "0.1"
tracing = "0.1"
uuid = { version = "1.0", features = ["v4"] }
```

## æ ¸å¿ƒæ¶æ„æ¨¡å¼

### 1. è¿è¡Œæ—¶åˆå§‹åŒ–æ¨¡å¼
ä½¿ç”¨ ModuForge-RS çš„å¼‚æ­¥è¿è¡Œæ—¶ï¼š

```rust
use mf_core::{ForgeResult, async_runtime::AsyncRuntime, types::RuntimeOptions};
use mf_state::{init_logging, StateConfig};
use mf_core::middleware::MiddlewareStack;

// åˆå§‹åŒ–å¼‚æ­¥è¿è¡Œæ—¶
async fn initialize_runtime() -> ForgeResult<AsyncRuntime> {
    // é…ç½®æ—¥å¿—ç³»ç»Ÿ
    init_logging("info", Some("logs/app.log"))?;
    
    // åˆ›å»ºè¿è¡Œæ—¶é…ç½®
    let mut options = RuntimeOptions::default();
    options.set_middleware_stack(MiddlewareStack::new());
    
    // åˆ›å»ºçŠ¶æ€é…ç½®
    let state_config = StateConfig::default();
    
    // åˆ›å»ºå¼‚æ­¥è¿è¡Œæ—¶å®ä¾‹
    AsyncRuntime::new(options, state_config).await
}
```

### 2. æ’ä»¶å’Œæ‰©å±•å¼€å‘æ¨¡å¼
é€šè¿‡ Extension ç³»ç»Ÿåˆ›å»ºæ’ä»¶ï¼š

```rust
use mf_core::extension::Extension;
use mf_state::{
    plugin::{Plugin, PluginSpec, PluginTrait, StateField},
    resource::Resource,
    state::{State, StateConfig},
    transaction::Transaction,
    error::StateResult,
};
use async_trait::async_trait;
use std::sync::Arc;

// 1. å®šä¹‰æ’ä»¶çŠ¶æ€èµ„æº
#[derive(Debug, Clone)]
pub struct MyPluginState {
    pub data: im::HashMap<String, String>,
    pub count: u64,
}

impl Resource for MyPluginState {}

impl MyPluginState {
    pub fn new() -> Self {
        Self {
            data: im::HashMap::new(),
            count: 0,
        }
    }
}

// 2. å®ç°çŠ¶æ€å­—æ®µç®¡ç†å™¨
#[derive(Debug)]
pub struct MyStateField;

#[async_trait]
impl StateField for MyStateField {
    async fn init(
        &self,
        _config: &StateConfig,
        _instance: Option<&State>,
    ) -> Arc<dyn Resource> {
        println!("åˆå§‹åŒ–æˆ‘çš„æ’ä»¶çŠ¶æ€");
        Arc::new(MyPluginState::new())
    }

    async fn apply(
        &self,
        tr: &Transaction,
        value: Arc<dyn Resource>,
        _old_state: &State,
        _new_state: &State,
    ) -> Arc<dyn Resource> {
        if let Ok(state) = value.clone().downcast::<MyPluginState>() {
            let mut new_state = (*state).clone();
            
            // æ ¹æ®äº‹åŠ¡å…ƒæ•°æ®æ›´æ–°çŠ¶æ€
            if let Some(action) = tr.get_meta::<String>("action") {
                match action.as_str() {
                    "increment" => {
                        new_state.count += 1;
                        println!("æ’ä»¶è®¡æ•°å™¨: {}", new_state.count);
                    }
                    "set_data" => {
                        if let Some(key) = tr.get_meta::<String>("key") {
                            if let Some(val) = tr.get_meta::<String>("value") {
                                new_state.data.insert(key.as_str().to_string(), val.as_str().to_string());
                            }
                        }
                    }
                    _ => {}
                }
            }
            
            Arc::new(new_state)
        } else {
            value
        }
    }
}

// 3. å®ç°æ’ä»¶è¡Œä¸º
#[derive(Debug)]
pub struct MyPlugin;

#[async_trait]
impl PluginTrait for MyPlugin {
    async fn append_transaction(
        &self,
        transactions: &[Transaction],
        _old_state: &State,
        _new_state: &State,
    ) -> StateResult<Option<Transaction>> {
        // æ£€æŸ¥äº‹åŠ¡å¹¶ç”Ÿæˆé™„åŠ äº‹åŠ¡
        for tr in transactions {
            if let Some(action) = tr.get_meta::<String>("action") {
                if action.as_str() == "my_action" {
                    let mut new_tr = Transaction::new();
                    new_tr.set_meta("generated_by", "my_plugin");
                    new_tr.set_meta("action", "increment");
                    return Ok(Some(new_tr));
                }
            }
        }
        Ok(None)
    }

    async fn filter_transaction(
        &self,
        transaction: &Transaction,
        _state: &State,
    ) -> bool {
        // è¿‡æ»¤é€»è¾‘ï¼šæ‹’ç»æŸäº›æ“ä½œ
        if let Some(action) = transaction.get_meta::<String>("action") {
            return action.as_str() != "forbidden_action";
        }
        true
    }
}

// 4. åˆ›å»ºå®Œæ•´çš„æ‰©å±•
pub fn create_my_extension() -> Extension {
    let mut extension = Extension::new();
    
    // åˆ›å»ºæ’ä»¶
    let plugin = Plugin::new(PluginSpec {
        key: ("my_plugin".to_string(), "v1".to_string()),
        state_field: Some(Arc::new(MyStateField)),
        tr: Some(Arc::new(MyPlugin)),
        priority: 10,
    });
    
    extension.add_plugin(Arc::new(plugin));
    extension
}

// 5. åœ¨è¿è¡Œæ—¶ä¸­ä½¿ç”¨æ‰©å±•
async fn create_runtime_with_plugin() -> ForgeResult<AsyncRuntime> {
    let mut options = RuntimeOptions::default();
    
    // æ·»åŠ æ‰©å±•åˆ°è¿è¡Œæ—¶é€‰é¡¹
    options.add_extension(mf_core::types::Extensions::E(create_my_extension()));
    
    let state_config = StateConfig::default();
    AsyncRuntime::new(options, state_config).await
}

### 3. èŠ‚ç‚¹å’Œæ–‡æ¡£æ“ä½œæ¨¡å¼

```rust
use mf_model::{
    node::Node as ModelNode,
    node_type::{NodeSpec, NodeEnum},
    attrs::Attrs,
    types::NodeId,
    tree::Tree,
    node_pool::NodePool,
};
use mf_transform::{
    node_step::{AddNodeStep, RemoveNodeStep},
    attr_step::AttrStep,
};
use std::sync::Arc;

// åˆ›å»ºæ–‡æ¡£èŠ‚ç‚¹
fn create_document_nodes() -> NodePool {
    // åˆ›å»ºæ ¹èŠ‚ç‚¹
    let root_node = ModelNode::new(
        "root",
        "document".to_string(),
        Attrs::default(),
        vec![],
        vec![]
    );
    
    // åˆ›å»ºæ®µè½èŠ‚ç‚¹
    let paragraph_node = ModelNode::new(
        "para_1",
        "paragraph".to_string(),
        Attrs::default(),
        vec![],
        vec![]
    );
    
    // æ„å»ºèŠ‚ç‚¹æšä¸¾
    let node_enum = NodeEnum(root_node, vec![
        NodeEnum(paragraph_node, vec![])
    ]);
    
    // åˆ›å»ºæ ‘å’ŒèŠ‚ç‚¹æ± 
    let tree = Tree::from(node_enum);
    NodePool::new(Arc::new(tree))
}

// æ“ä½œæ–‡æ¡£
async fn manipulate_document(runtime: &mut AsyncRuntime) -> ForgeResult<()> {
    let mut transaction = Transaction::new();
    
    // æ·»åŠ æ–°èŠ‚ç‚¹
    let new_node = ModelNode::new(
        "new_para",
        "paragraph".to_string(),
        Attrs::default(),
        vec![],
        vec![]
    );
    
    let add_step = AddNodeStep::new(new_node, Some(NodeId::from("root")));
    transaction.add_step(Box::new(add_step));
    
    // è®¾ç½®äº‹åŠ¡å…ƒæ•°æ®
    transaction.set_meta("action", "add_paragraph");
    transaction.set_meta("user_id", "user_123");
    
    // æ‰§è¡Œäº‹åŠ¡
    runtime.apply_transaction(transaction).await
}
```

### 4. ä¸­é—´ä»¶å¼€å‘æ¨¡å¼

```rust
use mf_core::middleware::{Middleware, MiddlewareStack};
use async_trait::async_trait;

#[derive(Debug)]
struct LoggingMiddleware {
    name: String,
}

impl LoggingMiddleware {
    pub fn new() -> Self {
        Self { name: "LoggingMiddleware".to_string() }
    }
}

#[async_trait]
impl Middleware for LoggingMiddleware {
    fn name(&self) -> String {
        self.name.clone()
    }

    async fn before_dispatch(
        &self,
        transaction: &mut Transaction,
    ) -> ForgeResult<()> {
        println!("ğŸ” [{}] äº‹åŠ¡å¤„ç†å¼€å§‹ - ID: {}", self.name, transaction.id);
        Ok(())
    }

    async fn after_dispatch(
        &self,
        state: Option<Arc<State>>,
        transactions: &[Transaction],
    ) -> ForgeResult<Option<Transaction>> {
        println!("âœ… [{}] äº‹åŠ¡å¤„ç†å®Œæˆ", self.name);
        Ok(None)
    }
}

// ä½¿ç”¨ä¸­é—´ä»¶
fn setup_middleware() -> MiddlewareStack {
    let mut middleware_stack = MiddlewareStack::new();
    middleware_stack.add(LoggingMiddleware::new());
    middleware_stack
}
```

### 5. äº‹ä»¶å¤„ç†æ¨¡å¼

```rust
use mf_core::event::{Event, EventHandler, EventBus};

#[derive(Debug)]
struct StateChangeHandler;

#[async_trait]
impl EventHandler<Event> for StateChangeHandler {
    async fn handle(&self, event: &Event) -> ForgeResult<()> {
        match event {
            Event::Create(state) => {
                println!("ğŸ‰ çŠ¶æ€åˆ›å»º: ç‰ˆæœ¬ {}", state.version);
            }
            Event::TrApply(tr_id, transactions, state) => {
                println!("ğŸ“ äº‹åŠ¡åº”ç”¨: ID {}, ç‰ˆæœ¬ {}", tr_id, state.version);
            }
            Event::Destroy => {
                println!("ğŸ—‘ï¸ çŠ¶æ€é”€æ¯");
            }
            Event::Stop => {
                println!("â¹ï¸ çŠ¶æ€åœæ­¢");
            }
        }
        Ok(())
    }
}

// è®¾ç½®äº‹ä»¶å¤„ç†
fn setup_event_handling() -> EventBus<Event> {
    let event_bus = EventBus::<Event>::new();
    event_bus.add_event_handler(Arc::new(StateChangeHandler)).unwrap();
    event_bus.start_event_loop();
    event_bus
}
```

## ä»£ç é£æ ¼å’Œæœ€ä½³å®è·µ

### é”™è¯¯å¤„ç†
- ä½¿ç”¨ `ForgeResult<T>` ä½œä¸ºè¿”å›ç±»å‹
- ä½¿ç”¨ `?` æ“ä½œç¬¦è¿›è¡Œé”™è¯¯ä¼ æ’­
- æä¾›æœ‰æ„ä¹‰çš„é”™è¯¯æ¶ˆæ¯

### å¼‚æ­¥ç¼–ç¨‹
- æ‰€æœ‰ I/O æ“ä½œä½¿ç”¨ `async/await`
- ä½¿ç”¨ `Arc<T>` è¿›è¡Œå…±äº«æ‰€æœ‰æƒ
- é¿å…åœ¨å¼‚æ­¥ä¸Šä¸‹æ–‡ä¸­é˜»å¡

### å†…å­˜ç®¡ç†
- ä¼˜å…ˆä½¿ç”¨ä¸å¯å˜æ•°æ®ç»“æ„ (`im::HashMap`, `im::Vector`)
- ä½¿ç”¨ `Arc` è€Œé `Rc` åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸­
- é¿å…ä¸å¿…è¦çš„å…‹éš†æ“ä½œ

### æµ‹è¯•
```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_plugin_integration() {
        let runtime = initialize_runtime().await.unwrap();
        // æµ‹è¯•é€»è¾‘
        assert!(runtime.is_healthy());
    }
}
```

## é¡¹ç›®ç»“æ„å»ºè®®
```
your-project/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib.rs              # åº“å…¥å£
â”‚   â”œâ”€â”€ plugins/            # æ’ä»¶æ¨¡å—
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ custom_plugin.rs
â”‚   â”‚   â””â”€â”€ business_plugin.rs
â”‚   â”œâ”€â”€ extensions/         # æ‰©å±•æ¨¡å—
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â””â”€â”€ custom_extensions.rs
â”‚   â”œâ”€â”€ middleware/         # ä¸­é—´ä»¶æ¨¡å—
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â””â”€â”€ auth_middleware.rs
â”‚   â”œâ”€â”€ handlers/           # ä¸šåŠ¡å¤„ç†å™¨
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â””â”€â”€ document_handler.rs
â”‚   â””â”€â”€ config/             # é…ç½®æ¨¡å—
â”‚       â”œâ”€â”€ mod.rs
â”‚       â””â”€â”€ app_config.rs
â”œâ”€â”€ Cargo.toml
â””â”€â”€ README.md
```

## æ€§èƒ½ä¼˜åŒ–å»ºè®®
- ä½¿ç”¨ `Arc<T>` åœ¨å¼‚æ­¥ä¸Šä¸‹æ–‡ä¸­å…±äº«æ‰€æœ‰æƒ
- ä¼˜å…ˆå€Ÿç”¨è€Œä¸æ˜¯å…‹éš†ï¼Œç‰¹åˆ«æ˜¯å¯¹äºä¸å¯å˜æ•°æ®
- ä½¿ç”¨ `tokio::spawn` å¤„ç† CPU å¯†é›†å‹ä»»åŠ¡
- åœ¨çƒ­è·¯å¾„ä¸­æœ€å°åŒ–å†…å­˜åˆ†é…
- è€ƒè™‘ä½¿ç”¨ `smallvec` å¤„ç†å°é›†åˆ
- ä½¿ç”¨å»¶è¿Ÿæ±‚å€¼å¤„ç†æ˜‚è´µçš„è®¡ç®—

## æµ‹è¯•æ¨¡å¼
```rust
#[cfg(test)]
mod tests {
    use super::*;
    use mf_state::{State, StateConfig};
    use tokio_test;

    #[tokio::test]
    async fn test_state_initialization() {
        let config = StateConfig::default();
        let state = State::new(config).await.unwrap();
        
        assert!(state.version() > 0);
    }

    #[tokio::test]
    async fn test_plugin_integration() {
        // æ’ä»¶é›†æˆæµ‹è¯•
    }
}
```

## é¿å…çš„åæ¨¡å¼
- åœ¨ç”Ÿäº§ä»£ç ä¸­ä½¿ç”¨ `unwrap()` æˆ– `expect()` è€Œä¸æä¾›åˆç†ç†ç”±
- å¿½ç•¥ç¼–è¯‘å™¨è­¦å‘Š
- åœ¨å¼‚æ­¥ä»£ç ä¸­è¿›è¡Œé˜»å¡æ“ä½œ
- å¤§å‹å‡½æ•°ï¼ˆå»ºè®®æ‹†åˆ†ä¸ºæ›´å°çš„å‡½æ•°ï¼‰
- æ·±å±‚åµŒå¥—ï¼ˆä½¿ç”¨æ—©æœŸè¿”å›å’Œä¿æŠ¤å­å¥ï¼‰
- å¯å˜å…¨å±€çŠ¶æ€
- å¿½ç•¥ ModuForge-RS çš„äº‹ä»¶é©±åŠ¨æ¶æ„

## æ—¥å¿—å’Œè°ƒè¯•
```rust
use mf_state::{info, debug, warn, error, init_logging};

// åˆå§‹åŒ–æ—¥å¿—ç³»ç»Ÿ
init_logging("debug", Some("logs/app.log")).unwrap();

// ä½¿ç”¨æ—¥å¿—å®
info!("åº”ç”¨å¯åŠ¨");
debug!("è°ƒè¯•ä¿¡æ¯: {:?}", data);
warn!("è­¦å‘Š: é…ç½®å¯èƒ½ä¸æ­£ç¡®");
error!("é”™è¯¯: æ“ä½œå¤±è´¥");
```

## æ’ä»¶å¼€å‘æŒ‡å—
è¯¦ç»†çš„æ’ä»¶å¼€å‘æ–‡æ¡£è¯·å‚è€ƒ `plugin-development-guide.md`ï¼ŒåŒ…å«ï¼š
- å®Œæ•´çš„æ’ä»¶ç»“æ„ï¼ˆResource, StateField, PluginTraitï¼‰
- çŠ¶æ€ç®¡ç†å’Œäº‹åŠ¡å¤„ç†
- æ’ä»¶é—´é€šä¿¡æœºåˆ¶
- èµ„æºå…±äº«å’Œæ€§èƒ½ä¼˜åŒ–
- å®Œæ•´çš„æµ‹è¯•ç¤ºä¾‹

## AI åŠ©æ‰‹æŒ‡å¯¼åŸåˆ™
å½“ååŠ©æ­¤é¡¹ç›®æ—¶ï¼š
1. å§‹ç»ˆè€ƒè™‘ ModuForge-RS çš„ä¸å¯å˜æ•°æ®ç»“æ„èŒƒå¼
2. å»ºè®®äº‹ä»¶é©±åŠ¨çš„çŠ¶æ€å˜æ›´è§£å†³æ–¹æ¡ˆ
3. æ¨èé€‚å½“çš„é”™è¯¯å¤„ç†æ¨¡å¼
4. è€ƒè™‘å»ºè®®çš„æ€§èƒ½å½±å“
5. ä¿æŒä¸ç°æœ‰æ¶æ„æ¨¡å¼çš„ä¸€è‡´æ€§
6. ä¸ºæ–°åŠŸèƒ½å»ºè®®æµ‹è¯•
7. è€ƒè™‘å‘åå…¼å®¹æ€§
8. éµå¾ª Rust æœ€ä½³å®è·µå’Œæƒ¯ç”¨è¯­æ³•
9. ä¼˜å…ˆè€ƒè™‘ç±»å‹å®‰å…¨å’Œå†…å­˜å®‰å…¨
10. åœ¨å»ºè®®æ›´æ”¹æ—¶è€ƒè™‘æ’ä»¶å’Œä¸­é—´ä»¶æ¶æ„
11. **æ’ä»¶å¼€å‘æ—¶ä½¿ç”¨æ­£ç¡®çš„ä¸‰å±‚ç»“æ„ï¼šResource + StateField + PluginTrait**
12. **ä½¿ç”¨äº‹åŠ¡å…ƒæ•°æ®è¿›è¡Œæ’ä»¶é—´é€šä¿¡å’ŒçŠ¶æ€ç®¡ç†** 