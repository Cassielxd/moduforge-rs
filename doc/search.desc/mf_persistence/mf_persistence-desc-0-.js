searchState.loadedDescShard("mf_persistence", 0, "持久化抽象层的公共 API。\n启动恢复：参考 price-storage 的做法（快照 + …\n持久化负载的序列化辅助工具。\n基于 SQLite 的 <code>EventStore</code> 实现。\n基于事件总线的持久化订阅者：在 TrApply …\n写入持久性与延迟之间的权衡。\n具体后端必须实现的最小持久化接口。\n用于启动引导的状态加载结果（快照 + …\n快照节奏与压缩等可调参数。\n事件存储的“仅追加”记录。\n…\n截止到 <code>upto_lsn</code> 的物化状态快照。\n追加单条事件。返回分配的 <code>lsn</code>。\n在单事务内批量追加事件。返回最后一条的 …\n…\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n…\n读取指定文档分片自 <code>from_lsn</code> …\n写入/替换快照，应保证原子性。\n…\nCRC32 校验，提供轻量级的数据完整性保护。\n可选的 zstd 压缩（level=1，优先速度）。\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n将步骤序列化结果以 RS(0x1E) 作为分隔拼接。\n<code>EventStore</code> 的 SQLite 具体实现。\n以独立事务追加一条事件记录。\n在单事务内批量追加多条事件以提升吞吐。\n…\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n返回该文档的最新快照（若存在）。\n读取指定文档在 <code>from_lsn</code> 之后的有序事件流。\n打开（或创建）数据库并初始化表结构与 …\n原子写入/替换快照。\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")