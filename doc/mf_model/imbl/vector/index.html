<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A persistent vector."><title>mf_model::imbl::vector - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-1a91846b.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="mf_model" data-themes="" data-resource-suffix="" data-rustdoc-version="1.88.0 (6b00bc388 2025-06-23)" data-channel="1.88.0" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../../../static.files/storage-4e99c027.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-7ef8a74a.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../mf_model/index.html">mf_<wbr>model</a><span class="version">0.5.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module vector</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#performance-notes" title="Performance Notes">Performance Notes</a></li></ul><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In mf_<wbr>model::<wbr>imbl</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">mf_model</a>::<wbr><a href="../index.html">imbl</a></div><h1>Module <span>vector</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A persistent vector.</p>
<p>This is a sequence of elements in insertion order - if you need a
list of things, any kind of list of things, this is what you’re
looking for.</p>
<p>It’s implemented as an <a href="https://infoscience.epfl.ch/record/213452/files/rrbvector.pdf">RRB vector</a> with <a href="http://deepsea.inria.fr/pasl/chunkedseq.pdf">smart
head/tail chunking</a>. In performance terms, this means
that practically every operation is O(log n), except push/pop on
both sides, which will be O(1) amortised, and O(log n) in the
worst case. In practice, the push/pop operations will be
blindingly fast, nearly on par with the native
<a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html"><code>VecDeque</code></a>, and other operations will have decent, if
not high, performance, but they all have more or less the same
O(log n) complexity, so you don’t need to keep their performance
characteristics in mind - everything, even splitting and merging,
is safe to use and never too slow.</p>
<h3 id="performance-notes"><a class="doc-anchor" href="#performance-notes">§</a>Performance Notes</h3>
<p>Because of the head/tail chunking technique, until you push a
number of items above double the tree’s branching factor (that’s
<code>self.len()</code> = 2 × <em>k</em> (where <em>k</em> = 64) = 128) on either side, the
data structure is still just a handful of arrays, not yet an RRB
tree, so you’ll see performance and memory characteristics fairly
close to <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a> or <a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html"><code>VecDeque</code></a>.</p>
<p>This means that the structure always preallocates four chunks of
size <em>k</em> (<em>k</em> being the tree’s branching factor), equivalent to a
<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a> with an initial capacity of 256. Beyond that, it will
allocate tree nodes of capacity <em>k</em> as needed.</p>
<p>In addition, vectors start out as single chunks, and only expand into the
full data structure once you go past the chunk size. This makes them
perform identically to <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a> at small sizes.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Chunks.html" title="struct mf_model::imbl::vector::Chunks">Chunks</a></dt><dd>An iterator over the leaf nodes of a vector.</dd><dt><a class="struct" href="struct.ChunksMut.html" title="struct mf_model::imbl::vector::ChunksMut">Chunks<wbr>Mut</a></dt><dd>A mutable iterator over the leaf nodes of a vector.</dd><dt><a class="struct" href="struct.ConsumingIter.html" title="struct mf_model::imbl::vector::ConsumingIter">Consuming<wbr>Iter</a></dt><dd>A consuming iterator over vectors with values of type <code>A</code>.</dd><dt><a class="struct" href="struct.GenericVector.html" title="struct mf_model::imbl::vector::GenericVector">Generic<wbr>Vector</a></dt><dd>A persistent vector.</dd><dt><a class="struct" href="struct.Iter.html" title="struct mf_model::imbl::vector::Iter">Iter</a></dt><dd>An iterator over vectors with values of type <code>A</code>.</dd><dt><a class="struct" href="struct.IterMut.html" title="struct mf_model::imbl::vector::IterMut">IterMut</a></dt><dd>A mutable iterator over vectors with values of type <code>A</code>.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.Focus.html" title="enum mf_model::imbl::vector::Focus">Focus</a></dt><dd>Focused indexing over a <a href="enum.Vector.html"><code>Vector</code></a>.</dd><dt><a class="enum" href="enum.FocusMut.html" title="enum mf_model::imbl::vector::FocusMut">Focus<wbr>Mut</a></dt><dd>A mutable version of <a href="enum.Focus.html"><code>Focus</code></a>.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.Vector.html" title="type mf_model::imbl::vector::Vector">Vector</a></dt><dd>Type alias for <a href="../struct.GenericVector.html" title="struct mf_model::imbl::GenericVector"><code>GenericVector</code></a> that uses <a href="../shared_ptr/type.DefaultSharedPtr.html" title="type mf_model::imbl::shared_ptr::DefaultSharedPtr"><code>DefaultSharedPtr</code></a> as the pointer type.</dd></dl></section></div></main></body></html>