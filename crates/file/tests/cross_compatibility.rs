//! Cross-compatibility tests between synchronous and asynchronous document implementations
//!
//! These tests ensure that files generated by either the sync or async implementation
//! can be read correctly by the other implementation, maintaining full compatibility.

use mf_file::{
    DocumentWriter, DocumentReader,
    AsyncDocumentWriter, AsyncDocumentReader,
    SegmentType, Result,
};
use tempfile::tempdir;
use tokio;

/// Test that a file written by sync can be read by async
#[tokio::test]
async fn sync_write_async_read() -> Result<()> {
    let dir = tempdir().unwrap();
    let path = dir.path().join("sync_to_async.mfd");

    // Write with sync
    {
        let mut writer = DocumentWriter::begin(&path)?;
        writer.add_segment(SegmentType("text".to_string()), b"Hello from sync")?;
        writer.add_segment(SegmentType("data".to_string()), b"Binary data 123")?;
        writer.add_segment(SegmentType("json".to_string()), br#"{"key": "value"}"#)?;

        // Add a large segment to test compression
        let large_data = vec![42u8; 100_000];
        writer.add_segment(SegmentType("large".to_string()), &large_data)?;

        writer.finalize()?;
    }

    // Read with async
    {
        let reader = AsyncDocumentReader::open(&path).await?;

        // Read specific segments
        let text = reader.get_segment(&SegmentType("text".to_string())).await?;
        assert_eq!(text.as_deref(), Some(b"Hello from sync".as_slice()));

        let data = reader.get_segment(&SegmentType("data".to_string())).await?;
        assert_eq!(data.as_deref(), Some(b"Binary data 123".as_slice()));

        let json = reader.get_segment(&SegmentType("json".to_string())).await?;
        assert_eq!(json.as_deref(), Some(br#"{"key": "value"}"#.as_slice()));

        let large = reader.get_segment(&SegmentType("large".to_string())).await?;
        assert_eq!(large.as_deref(), Some(vec![42u8; 100_000].as_slice()));

        // Stream all segments
        use futures::StreamExt;
        let mut count = 0;
        let stream = reader.stream_segments();
        futures::pin_mut!(stream);
        while let Some(result) = stream.next().await {
            let (_kind, _data) = result?;
            count += 1;
        }
        assert_eq!(count, 4);
    }

    Ok(())
}

/// Test that a file written by async can be read by sync
#[tokio::test]
async fn async_write_sync_read() -> Result<()> {
    let dir = tempdir().unwrap();
    let path = dir.path().join("async_to_sync.mfd");

    // Write with async (standard mode - compatible with sync)
    {
        let writer = AsyncDocumentWriter::begin_standard(&path).await?;
        writer.add_segment(SegmentType("text".to_string()), b"Hello from async".to_vec()).await?;
        writer.add_segment(SegmentType("data".to_string()), b"Binary data 456".to_vec()).await?;
        writer.add_segment(SegmentType("json".to_string()), br#"{"async": true}"#.to_vec()).await?;

        // Add a large segment
        let large_data = vec![99u8; 100_000];
        writer.add_segment(SegmentType("large".to_string()), large_data).await?;

        writer.finalize().await?;
    }

    // Read with sync
    {
        let reader = DocumentReader::open(&path)?;

        // Read all text segments
        let mut text_found = false;
        reader.read_segments(SegmentType("text".to_string()), |_index, data| {
            assert_eq!(data, b"Hello from async");
            text_found = true;
            Ok(())
        })?;
        assert!(text_found);

        // Read all data segments
        let mut data_found = false;
        reader.read_segments(SegmentType("data".to_string()), |_index, data| {
            assert_eq!(data, b"Binary data 456");
            data_found = true;
            Ok(())
        })?;
        assert!(data_found);

        // Read all json segments
        let mut json_found = false;
        reader.read_segments(SegmentType("json".to_string()), |_index, data| {
            assert_eq!(data, br#"{"async": true}"#);
            json_found = true;
            Ok(())
        })?;
        assert!(json_found);

        // Read large segment
        let mut large_found = false;
        reader.read_segments(SegmentType("large".to_string()), |_index, data| {
            assert_eq!(data, vec![99u8; 100_000].as_slice());
            large_found = true;
            Ok(())
        })?;
        assert!(large_found);

        // Verify segment count
        assert_eq!(reader.segments().len(), 4);
    }

    Ok(())
}

/// Test that async with parallel compression can still be read by sync
#[tokio::test]
async fn async_parallel_write_sync_read() -> Result<()> {
    let dir = tempdir().unwrap();
    let path = dir.path().join("async_parallel_to_sync.mfd");

    // Write with async (parallel compression mode)
    {
        let writer = AsyncDocumentWriter::begin(&path).await?;

        // Add multiple segments
        let segments = vec![
            (SegmentType("seg1".to_string()), b"First segment".to_vec()),
            (SegmentType("seg2".to_string()), b"Second segment".to_vec()),
            (SegmentType("seg3".to_string()), vec![1, 2, 3, 4, 5]),
        ];

        writer.add_segments_batch(segments).await?;

        // Add a very large segment that will trigger parallel compression
        let huge_data = vec![77u8; 1_000_000];
        writer.add_segment(SegmentType("huge".to_string()), huge_data.clone()).await?;

        writer.finalize().await?;
    }

    // Read with sync - should handle the parallel compression flag gracefully
    {
        let reader = DocumentReader::open(&path)?;

        // Verify we can read all segments
        assert_eq!(reader.segments().len(), 4);

        // Read the huge segment
        let mut huge_found = false;
        reader.read_segments(SegmentType("huge".to_string()), |_index, data| {
            assert_eq!(data.len(), 1_000_000);
            assert_eq!(data[0], 77);
            assert_eq!(data[999_999], 77);
            huge_found = true;
            Ok(())
        })?;
        assert!(huge_found);
    }

    Ok(())
}

/// Test bidirectional compatibility with mixed operations
#[tokio::test]
async fn bidirectional_compatibility() -> Result<()> {
    let dir = tempdir().unwrap();

    // Test 1: Sync write -> Async read -> Async write -> Sync read
    let path1 = dir.path().join("bidirectional1.mfd");

    // Sync write
    {
        let mut writer = DocumentWriter::begin(&path1)?;
        writer.add_segment(SegmentType("sync".to_string()), b"From sync writer")?;
        writer.finalize()?;
    }

    // Async read
    {
        let reader = AsyncDocumentReader::open(&path1).await?;
        let data = reader.get_segment(&SegmentType("sync".to_string())).await?;
        assert_eq!(data.as_deref(), Some(b"From sync writer".as_slice()));
    }

    // Test 2: Async write -> Sync read -> Sync write -> Async read
    let path2 = dir.path().join("bidirectional2.mfd");

    // Async write
    {
        let writer = AsyncDocumentWriter::begin_standard(&path2).await?;
        writer.add_segment(SegmentType("async".to_string()), b"From async writer".to_vec()).await?;
        writer.finalize().await?;
    }

    // Sync read
    {
        let reader = DocumentReader::open(&path2)?;
        let mut found = false;
        reader.read_segments(SegmentType("async".to_string()), |_index, data| {
            assert_eq!(data, b"From async writer");
            found = true;
            Ok(())
        })?;
        assert!(found);
    }

    Ok(())
}

/// Test that tail pointer optimization works correctly in both implementations
#[tokio::test]
async fn tail_pointer_optimization() -> Result<()> {
    let dir = tempdir().unwrap();

    // Test sync write with tail pointer
    let sync_path = dir.path().join("sync_tail.mfd");
    {
        let mut writer = DocumentWriter::begin(&sync_path)?;
        for i in 0..100 {
            let data = format!("Segment {}", i);
            writer.add_segment(SegmentType(format!("seg{}", i)), data.as_bytes())?;
        }
        writer.finalize()?;
    }

    // Verify async reader uses tail pointer (should be fast even with many segments)
    {
        let start = std::time::Instant::now();
        let reader = AsyncDocumentReader::open(&sync_path).await?;
        let duration = start.elapsed();

        // Opening should be fast with tail pointer
        assert!(duration.as_millis() < 100, "Opening took too long: {:?}", duration);

        // Verify we can read segments
        let seg50 = reader.get_segment(&SegmentType("seg50".to_string())).await?;
        assert_eq!(seg50.as_deref(), Some(b"Segment 50".as_slice()));
    }

    // Test async write with tail pointer
    let async_path = dir.path().join("async_tail.mfd");
    {
        let writer = AsyncDocumentWriter::begin_standard(&async_path).await?;
        for i in 0..100 {
            let data = format!("Async segment {}", i);
            writer.add_segment(SegmentType(format!("aseg{}", i)), data.into_bytes()).await?;
        }
        writer.finalize().await?;
    }

    // Verify sync reader uses tail pointer
    {
        let start = std::time::Instant::now();
        let reader = DocumentReader::open(&async_path)?;
        let duration = start.elapsed();

        // Opening should be fast with tail pointer
        assert!(duration.as_millis() < 100, "Opening took too long: {:?}", duration);

        // Verify we can read segments
        let mut found = false;
        reader.read_segments(SegmentType("aseg75".to_string()), |_index, data| {
            assert_eq!(data, b"Async segment 75");
            found = true;
            Ok(())
        })?;
        assert!(found);
    }

    Ok(())
}

/// Test edge cases and error handling
#[tokio::test]
async fn edge_cases_compatibility() -> Result<()> {
    let dir = tempdir().unwrap();

    // Test empty segments handling (should fail)
    let empty_path = dir.path().join("empty.mfd");
    {
        let mut writer = DocumentWriter::begin(&empty_path)?;
        // Try to add empty segment - should fail
        let result = writer.add_segment(SegmentType("empty".to_string()), b"");
        assert!(result.is_err());

        // Add valid segment
        writer.add_segment(SegmentType("valid".to_string()), b"not empty")?;
        writer.finalize()?;
    }

    // Verify async can read it
    {
        let reader = AsyncDocumentReader::open(&empty_path).await?;
        let valid = reader.get_segment(&SegmentType("valid".to_string())).await?;
        assert_eq!(valid.as_deref(), Some(b"not empty".as_slice()));

        // Empty segment should not exist
        let empty = reader.get_segment(&SegmentType("empty".to_string())).await?;
        assert_eq!(empty, None);
    }

    // Test very small file
    let small_path = dir.path().join("small.mfd");
    {
        let writer = AsyncDocumentWriter::begin_standard(&small_path).await?;
        writer.add_segment(SegmentType("x".to_string()), vec![1]).await?;
        writer.finalize().await?;
    }

    // Sync should read it fine
    {
        let reader = DocumentReader::open(&small_path)?;
        assert_eq!(reader.segments().len(), 1);

        let payload = reader.segment_payload(0)?;
        assert_eq!(payload, vec![1]);
    }

    Ok(())
}