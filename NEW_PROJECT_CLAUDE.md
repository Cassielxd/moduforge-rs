# CLAUDE.md - ä½¿ç”¨ ModuForge-RS æ¡†æ¶

è¿™ä¸ªæ–‡ä»¶æä¾›åœ¨æ–°é¡¹ç›®ä¸­ä½¿ç”¨ ModuForge-RS æ¡†æ¶çš„å®Œæ•´æŒ‡å¯¼ã€‚

## é¡¹ç›®æ¦‚è¿°

æœ¬é¡¹ç›®åŸºäº ModuForge-RS æ¡†æ¶æ„å»ºï¼Œè¿™æ˜¯ä¸€ä¸ªå…¨é¢çš„ Rust çŠ¶æ€ç®¡ç†å’Œæ•°æ®è½¬æ¢æ¡†æ¶ï¼Œå…·æœ‰ä¸å¯å˜æ•°æ®ç»“æ„ã€äº‹ä»¶é©±åŠ¨æ¶æ„ã€åä½œåŠŸèƒ½å’Œå¼ºå¤§çš„è§„åˆ™å¼•æ“ã€‚

## æ¡†æ¶æ¶æ„å›¾

### æ•´ä½“æ¶æ„æ¦‚è§ˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           ModuForge-RS æ¡†æ¶æ¶æ„                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚  â”‚ å‰ç«¯å±‚ (Frontend)â”‚    â”‚  åä½œå±‚ (Collab) â”‚    â”‚ è§„åˆ™å¼•æ“ (Rules) â”‚              â”‚
â”‚  â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚              â”‚
â”‚  â”‚ â€¢ Tauri/Electronâ”‚    â”‚ â€¢ å®æ—¶åŒæ­¥       â”‚    â”‚ â€¢ è¡¨è¾¾å¼è¯­è¨€     â”‚              â”‚
â”‚  â”‚ â€¢ Vue/React     â”‚    â”‚ â€¢ CRDT (Yrs)    â”‚    â”‚ â€¢ å†³ç­–å¼•æ“       â”‚              â”‚
â”‚  â”‚ â€¢ IPC é€šä¿¡      â”‚    â”‚ â€¢ WebSocket     â”‚    â”‚ â€¢ æ¨¡æ¿æ¸²æŸ“       â”‚              â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚           â”‚                       â”‚                       â”‚                     â”‚
â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚
â”‚                                   â”‚                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                      æ ¸å¿ƒè¿è¡Œæ—¶ (Core Runtime)                           â”‚   â”‚
â”‚  â”‚                                 â”‚                                       â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚ æ‰©å±•ç®¡ç†å™¨   â”‚    â”‚   ä¸­é—´ä»¶  â”‚  é“¾      â”‚    â”‚   æ’ä»¶ç³»ç»Ÿ          â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ Extension   â”‚    â”‚ Middlewareâ”‚ Chain    â”‚    â”‚   Plugin System     â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ Manager     â”‚    â”‚           â”‚          â”‚    â”‚                     â”‚  â”‚   â”‚
â”‚  â”‚  â”‚             â”‚    â”‚ â€¢ è¯·æ±‚æ‹¦æˆªâ”‚          â”‚    â”‚ â€¢ çŠ¶æ€å­—æ®µ          â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ â€¢ èŠ‚ç‚¹æ³¨å†Œ  â”‚    â”‚ â€¢ å“åº”å¤„ç†â”‚          â”‚    â”‚ â€¢ ç”Ÿå‘½å‘¨æœŸç®¡ç†      â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ â€¢ æ ‡è®°æ³¨å†Œ  â”‚    â”‚ â€¢ æ—¥å¿—è®°å½•â”‚          â”‚    â”‚ â€¢ ä¾èµ–æ³¨å…¥          â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ â€¢ æ¨¡å¼éªŒè¯  â”‚    â”‚ â€¢ æ€§èƒ½ç›‘æ§â”‚          â”‚    â”‚                     â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â”‚                                 â”‚                                       â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚                    äº‹åŠ¡å¤„ç†å±‚ (Transaction Layer)                   â”‚  â”‚   â”‚
â”‚  â”‚  â”‚                                                                     â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ â”‚   äº‹åŠ¡ç®¡ç†   â”‚  â”‚   æ­¥éª¤æ‰§è¡Œ   â”‚  â”‚   å›æ»šæœºåˆ¶   â”‚  â”‚   å†å²ç®¡ç†   â”‚ â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ â”‚ Transaction â”‚  â”‚    Step     â”‚  â”‚   Rollback  â”‚  â”‚   History   â”‚ â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ â”‚   Manager   â”‚  â”‚  Execution  â”‚  â”‚             â”‚  â”‚   Manager   â”‚ â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ â”‚             â”‚  â”‚             â”‚  â”‚             â”‚  â”‚             â”‚ â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ â”‚ â€¢ ACID ä¿è¯ â”‚  â”‚ â€¢ åŸå­æ“ä½œ  â”‚  â”‚ â€¢ æ’¤é”€/é‡åš â”‚  â”‚ â€¢ ç‰ˆæœ¬æ§åˆ¶  â”‚ â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ â”‚ â€¢ æ‰¹é‡å¤„ç†  â”‚  â”‚ â€¢ é¡ºåºæ‰§è¡Œ  â”‚  â”‚ â€¢ çŠ¶æ€æ¢å¤  â”‚  â”‚ â€¢ åˆ†æ”¯ç®¡ç†  â”‚ â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                   â”‚                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                        çŠ¶æ€ç®¡ç†å±‚ (State Layer)                         â”‚   â”‚
â”‚  â”‚                                 â”‚                                       â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚  çŠ¶æ€å®¹å™¨   â”‚    â”‚   èµ„æº   â”‚   ç®¡ç†    â”‚    â”‚    äº‹ä»¶ç³»ç»Ÿ         â”‚  â”‚   â”‚
â”‚  â”‚  â”‚    State    â”‚    â”‚ Resource â”‚ Manager   â”‚    â”‚  Event System       â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ Container   â”‚    â”‚          â”‚           â”‚    â”‚                     â”‚  â”‚   â”‚
â”‚  â”‚  â”‚             â”‚    â”‚          â”‚           â”‚    â”‚ â€¢ äº‹ä»¶å‘å¸ƒ          â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ â€¢ ä¸å¯å˜æ€§  â”‚    â”‚ â€¢ ç¼“å­˜   â”‚           â”‚    â”‚ â€¢ äº‹ä»¶è®¢é˜…          â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ â€¢ ç»“æ„å…±äº«  â”‚    â”‚ â€¢ è¿æ¥æ±  â”‚           â”‚    â”‚ â€¢ å¼‚æ­¥å¤„ç†          â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ â€¢ å¹¶å‘å®‰å…¨  â”‚    â”‚ â€¢ é…ç½®   â”‚           â”‚    â”‚ â€¢ ç±»å‹å®‰å…¨          â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                   â”‚                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                       æ•°æ®æ¨¡å‹å±‚ (Model Layer)                          â”‚   â”‚
â”‚  â”‚                                 â”‚                                       â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚   èŠ‚ç‚¹æ ‘    â”‚    â”‚   å±æ€§   â”‚   æ ‡è®°    â”‚    â”‚      æ¨¡å¼éªŒè¯       â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  Node Tree  â”‚    â”‚  Attrs   â”‚  Marks    â”‚    â”‚  Schema Validation  â”‚  â”‚   â”‚
â”‚  â”‚  â”‚             â”‚    â”‚          â”‚           â”‚    â”‚                     â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ â€¢ å±‚æ¬¡ç»“æ„  â”‚    â”‚ â€¢ é”®å€¼å¯¹ â”‚ â€¢ æ ¼å¼åŒ–  â”‚    â”‚ â€¢ ç±»å‹æ£€æŸ¥          â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ â€¢ éå†æ“ä½œ  â”‚    â”‚ â€¢ ç±»å‹åŒ– â”‚ â€¢ æ ·å¼    â”‚    â”‚ â€¢ çº¦æŸéªŒè¯          â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ â€¢ æŸ¥è¯¢è¯­æ³•  â”‚    â”‚ â€¢ åºåˆ—åŒ– â”‚ â€¢ è¯­ä¹‰    â”‚    â”‚ â€¢ å†…å®¹æ¨¡å¼          â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                   â”‚                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                      å­˜å‚¨ä¸ I/O å±‚ (Storage & I/O)                      â”‚   â”‚
â”‚  â”‚                                 â”‚                                       â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚  æ–‡ä»¶ç³»ç»Ÿ   â”‚    â”‚   æŒä¹…åŒ– â”‚   æœç´¢    â”‚    â”‚     ç½‘ç»œé€šä¿¡        â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ File System â”‚    â”‚Persistenceâ”‚  Search   â”‚    â”‚   Network Comm      â”‚  â”‚   â”‚
â”‚  â”‚  â”‚             â”‚    â”‚           â”‚           â”‚    â”‚                     â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ â€¢ å¤šæ ¼å¼    â”‚    â”‚ â€¢ SQLite  â”‚ â€¢ ç´¢å¼•    â”‚    â”‚ â€¢ WebSocket         â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ â€¢ å‹ç¼©      â”‚    â”‚ â€¢ å¿«ç…§    â”‚ â€¢ æŸ¥è¯¢    â”‚    â”‚ â€¢ HTTP API          â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ â€¢ åŠ å¯†      â”‚    â”‚ â€¢ æ¢å¤    â”‚ â€¢ æ’åº    â”‚    â”‚ â€¢ æ¶ˆæ¯é˜Ÿåˆ—          â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ•°æ®æµå›¾

```
å‰ç«¯ UI (Frontend)                       Rust åç«¯ (Backend)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                             â”‚         â”‚                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚         â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   å‰ç«¯æ¡†æ¶           â”‚    â”‚         â”‚    â”‚   Tauri Commands    â”‚  â”‚
â”‚  â”‚ (Vue/React/Svelte)  â”‚    â”‚         â”‚    â”‚                     â”‚  â”‚
â”‚  â”‚                     â”‚    â”‚   IPC   â”‚    â”‚ â€¢ ä¸šåŠ¡é€»è¾‘å¤„ç†       â”‚  â”‚
â”‚  â”‚ â€¢ ç”¨æˆ·ç•Œé¢          â”‚â—€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â–¶â”‚ â€¢ çŠ¶æ€ç®¡ç†          â”‚  â”‚
â”‚  â”‚ â€¢ äº‹ä»¶å¤„ç†          â”‚    â”‚         â”‚    â”‚ â€¢ æ•°æ®éªŒè¯          â”‚  â”‚
â”‚  â”‚ â€¢ çŠ¶æ€åŒæ­¥          â”‚    â”‚         â”‚    â”‚                     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚         â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                             â”‚         â”‚              â”‚              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚         â”‚              â–¼              â”‚
â”‚  â”‚   Tauri API         â”‚    â”‚         â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                     â”‚    â”‚         â”‚    â”‚   ModuForge Core    â”‚  â”‚
â”‚  â”‚ â€¢ invoke()          â”‚    â”‚         â”‚    â”‚                     â”‚  â”‚
â”‚  â”‚ â€¢ listen()          â”‚    â”‚         â”‚    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”‚
â”‚  â”‚ â€¢ emit()            â”‚    â”‚         â”‚    â”‚ â”‚   ä¸­é—´ä»¶é“¾       â”‚ â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚         â”‚    â”‚ â”‚ Middleware Chainâ”‚ â”‚  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚
                                        â”‚    â”‚          â”‚          â”‚  â”‚
                                        â”‚    â”‚          â–¼          â”‚  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”‚
â”‚   åä½œæœåŠ¡ (å¯é€‰)            â”‚         â”‚    â”‚ â”‚   äº‹åŠ¡å±‚         â”‚ â”‚  â”‚
â”‚ Collaboration Service       â”‚         â”‚    â”‚ â”‚ Transaction     â”‚ â”‚  â”‚
â”‚                             â”‚         â”‚    â”‚ â”‚    Layer        â”‚ â”‚  â”‚
â”‚ â€¢ WebSocket è¿æ¥            â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”¤                 â”‚ â”‚  â”‚
â”‚ â€¢ CRDT åŒæ­¥                 â”‚         â”‚    â”‚ â”‚ â€¢ ACID ä¿è¯     â”‚ â”‚  â”‚
â”‚ â€¢ å¤šç”¨æˆ·åä½œ                â”‚         â”‚    â”‚ â”‚ â€¢ æ‰¹é‡å¤„ç†      â”‚ â”‚  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚
                                        â”‚    â”‚          â”‚          â”‚  â”‚
                                        â”‚    â”‚          â–¼          â”‚  â”‚
                                        â”‚    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”‚
                                        â”‚    â”‚ â”‚   çŠ¶æ€å±‚         â”‚ â”‚  â”‚
                                        â”‚    â”‚ â”‚  State Layer    â”‚ â”‚  â”‚
                                        â”‚    â”‚ â”‚                 â”‚ â”‚  â”‚
                                        â”‚    â”‚ â”‚ â€¢ ä¸å¯å˜çŠ¶æ€    â”‚ â”‚  â”‚
                                        â”‚    â”‚ â”‚ â€¢ äº‹ä»¶å‘å¸ƒ      â”‚ â”‚  â”‚
                                        â”‚    â”‚ â”‚ â€¢ æ’ä»¶ç³»ç»Ÿ      â”‚ â”‚  â”‚
                                        â”‚    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚
                                        â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
                                        â”‚              â”‚              â”‚
                                        â”‚              â–¼              â”‚
                                        â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
                                        â”‚    â”‚   å­˜å‚¨å±‚            â”‚  â”‚
                                        â”‚    â”‚  Storage Layer     â”‚  â”‚
                                        â”‚    â”‚                    â”‚  â”‚
                                        â”‚    â”‚ â€¢ æ–‡ä»¶ç³»ç»Ÿ         â”‚  â”‚
                                        â”‚    â”‚ â€¢ æ•°æ®åº“           â”‚  â”‚
                                        â”‚    â”‚ â€¢ æœç´¢å¼•æ“         â”‚  â”‚
                                        â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
                                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

IPC é€šä¿¡æœºåˆ¶:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â€¢ invoke(): å‰ç«¯è°ƒç”¨åç«¯å‡½æ•° (Command Pattern)
â€¢ listen(): å‰ç«¯ç›‘å¬åç«¯äº‹ä»¶ (Event Pattern) 
â€¢ emit(): åç«¯å‘å‰ç«¯å‘é€äº‹ä»¶ (Publish Pattern)
```

### ç»„ä»¶äº¤äº’å›¾

```
åº”ç”¨å±‚ Application Layer
â”‚
â”œâ”€â”€ ç¼–è¾‘å™¨ Editor
â”‚   â”œâ”€â”€ é…ç½® Configuration
â”‚   â”œâ”€â”€ æ‰©å±•ç®¡ç† Extension Management
â”‚   â””â”€â”€ ç”Ÿå‘½å‘¨æœŸ Lifecycle
â”‚
â”œâ”€â”€ ä¸­é—´ä»¶é“¾ Middleware Chain
â”‚   â”œâ”€â”€ è¯·æ±‚å¤„ç† Request Processing
â”‚   â”œâ”€â”€ å“åº”æ‹¦æˆª Response Interception
â”‚   â””â”€â”€ æ¨ªåˆ‡å…³æ³¨ç‚¹ Cross-cutting Concerns
â”‚
â”œâ”€â”€ äº‹åŠ¡ç³»ç»Ÿ Transaction System
â”‚   â”œâ”€â”€ äº‹åŠ¡ç®¡ç†å™¨ Transaction Manager
â”‚   â”‚   â”œâ”€â”€ å¼€å§‹äº‹åŠ¡ Begin Transaction
â”‚   â”‚   â”œâ”€â”€ æäº¤äº‹åŠ¡ Commit Transaction
â”‚   â”‚   â””â”€â”€ å›æ»šäº‹åŠ¡ Rollback Transaction
â”‚   â”‚
â”‚   â”œâ”€â”€ æ­¥éª¤æ‰§è¡Œå™¨ Step Executor
â”‚   â”‚   â”œâ”€â”€ èŠ‚ç‚¹æ“ä½œ Node Operations
â”‚   â”‚   â”‚   â”œâ”€â”€ æ·»åŠ èŠ‚ç‚¹ Add Node
â”‚   â”‚   â”‚   â”œâ”€â”€ åˆ é™¤èŠ‚ç‚¹ Remove Node
â”‚   â”‚   â”‚   â””â”€â”€ æ›´æ–°èŠ‚ç‚¹ Update Node
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ å±æ€§æ“ä½œ Attribute Operations
â”‚   â”‚   â”‚   â”œâ”€â”€ è®¾ç½®å±æ€§ Set Attribute
â”‚   â”‚   â”‚   â””â”€â”€ åˆ é™¤å±æ€§ Remove Attribute
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ æ ‡è®°æ“ä½œ Mark Operations
â”‚   â”‚       â”œâ”€â”€ æ·»åŠ æ ‡è®° Add Mark
â”‚   â”‚       â””â”€â”€ åˆ é™¤æ ‡è®° Remove Mark
â”‚   â”‚
â”‚   â””â”€â”€ å†å²ç®¡ç†å™¨ History Manager
â”‚       â”œâ”€â”€ æ’¤é”€ Undo
â”‚       â”œâ”€â”€ é‡åš Redo
â”‚       â””â”€â”€ å¿«ç…§ Snapshot
â”‚
â”œâ”€â”€ çŠ¶æ€ç®¡ç† State Management
â”‚   â”œâ”€â”€ çŠ¶æ€å®¹å™¨ State Container
â”‚   â”‚   â”œâ”€â”€ ä¸å¯å˜çŠ¶æ€ Immutable State
â”‚   â”‚   â”œâ”€â”€ ç»“æ„å…±äº« Structural Sharing
â”‚   â”‚   â””â”€â”€ å¹¶å‘è®¿é—® Concurrent Access
â”‚   â”‚
â”‚   â”œâ”€â”€ èµ„æºç®¡ç†å™¨ Resource Manager
â”‚   â”‚   â”œâ”€â”€ è¿æ¥æ±  Connection Pool
â”‚   â”‚   â”œâ”€â”€ ç¼“å­˜ç³»ç»Ÿ Cache System
â”‚   â”‚   â””â”€â”€ é…ç½®ç®¡ç† Configuration
â”‚   â”‚
â”‚   â””â”€â”€ äº‹ä»¶ç³»ç»Ÿ Event System
â”‚       â”œâ”€â”€ äº‹ä»¶å‘å¸ƒå™¨ Event Publisher
â”‚       â”œâ”€â”€ äº‹ä»¶è®¢é˜…å™¨ Event Subscriber
â”‚       â””â”€â”€ äº‹ä»¶è·¯ç”± Event Router
â”‚
â”œâ”€â”€ æ•°æ®æ¨¡å‹ Data Model
â”‚   â”œâ”€â”€ èŠ‚ç‚¹æ ‘ Node Tree
â”‚   â”‚   â”œâ”€â”€ å±‚æ¬¡ç»“æ„ Hierarchical Structure
â”‚   â”‚   â”œâ”€â”€ éå†ç®—æ³• Traversal Algorithms
â”‚   â”‚   â””â”€â”€ æŸ¥è¯¢æ¥å£ Query Interface
â”‚   â”‚
â”‚   â”œâ”€â”€ å±æ€§ç³»ç»Ÿ Attribute System
â”‚   â”‚   â”œâ”€â”€ ç±»å‹ç³»ç»Ÿ Type System
â”‚   â”‚   â”œâ”€â”€ éªŒè¯å™¨ Validators
â”‚   â”‚   â””â”€â”€ åºåˆ—åŒ– Serialization
â”‚   â”‚
â”‚   â””â”€â”€ æ¨¡å¼ç®¡ç† Schema Management
â”‚       â”œâ”€â”€ ç±»å‹å®šä¹‰ Type Definition
â”‚       â”œâ”€â”€ çº¦æŸéªŒè¯ Constraint Validation
â”‚       â””â”€â”€ è¿ç§»æ”¯æŒ Migration Support
â”‚
â””â”€â”€ å­˜å‚¨å±‚ Storage Layer
    â”œâ”€â”€ æ–‡ä»¶ç³»ç»Ÿ File System
    â”‚   â”œâ”€â”€ å¤šæ ¼å¼æ”¯æŒ Multi-format Support
    â”‚   â”‚   â”œâ”€â”€ JSON
    â”‚   â”‚   â”œâ”€â”€ CBOR
    â”‚   â”‚   â””â”€â”€ MessagePack
    â”‚   â”‚
    â”‚   â”œâ”€â”€ å‹ç¼©ç®—æ³• Compression
    â”‚   â””â”€â”€ åŠ å¯†æ”¯æŒ Encryption
    â”‚
    â”œâ”€â”€ æŒä¹…åŒ– Persistence
    â”‚   â”œâ”€â”€ SQLite æ•°æ®åº“ SQLite Database
    â”‚   â”œâ”€â”€ å¿«ç…§ç®¡ç† Snapshot Management
    â”‚   â””â”€â”€ å¢é‡å¤‡ä»½ Incremental Backup
    â”‚
    â””â”€â”€ æœç´¢å¼•æ“ Search Engine
        â”œâ”€â”€ ç´¢å¼•æ„å»º Index Building
        â”œâ”€â”€ æŸ¥è¯¢è§£æ Query Parsing
        â””â”€â”€ ç»“æœæ’åº Result Ranking
```

### æ ¸å¿ƒè®¾è®¡æ¨¡å¼

#### 1. CQRS (å‘½ä»¤æŸ¥è¯¢è´£ä»»åˆ†ç¦»)
```
å‘½ä»¤ç«¯ (Command Side)        æŸ¥è¯¢ç«¯ (Query Side)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     å‘½ä»¤å¤„ç†å™¨       â”‚     â”‚     æŸ¥è¯¢å¤„ç†å™¨       â”‚
â”‚  Command Handler    â”‚     â”‚   Query Handler     â”‚
â”‚                     â”‚     â”‚                     â”‚
â”‚ â€¢ äº‹åŠ¡æ“ä½œ          â”‚     â”‚ â€¢ è¯»å–æ“ä½œ          â”‚
â”‚ â€¢ çŠ¶æ€å˜æ›´          â”‚     â”‚ â€¢ æ•°æ®æŠ•å½±          â”‚
â”‚ â€¢ äº‹ä»¶å‘å¸ƒ          â”‚     â”‚ â€¢ ç¼“å­˜ä¼˜åŒ–          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚                           â–²
           â”‚                           â”‚
           â–¼                           â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              äº‹ä»¶å­˜å‚¨å’ŒçŠ¶æ€                      â”‚
â”‚           Event Store & State                   â”‚
â”‚                                                 â”‚
â”‚ â€¢ ä¸å¯å˜äº‹ä»¶æ—¥å¿—                                â”‚
â”‚ â€¢ çŠ¶æ€å¿«ç…§                                      â”‚
â”‚ â€¢ ç‰ˆæœ¬æ§åˆ¶                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 2. äº‹ä»¶é©±åŠ¨æ¶æ„ (Event-Driven Architecture)
```
äº‹ä»¶ç”Ÿäº§è€…          äº‹ä»¶æ€»çº¿          äº‹ä»¶æ¶ˆè´¹è€…
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ä¸šåŠ¡æ“ä½œ   â”‚â”€â”€â”€â–¶â”‚   äº‹ä»¶è·¯ç”±   â”‚â”€â”€â”€â–¶â”‚   UI æ›´æ–°    â”‚
â”‚ Business Op â”‚    â”‚Event Router â”‚    â”‚ UI Update   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                          â”œâ”€â”€â”€â–¶â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                          â”‚    â”‚   æŒä¹…åŒ–     â”‚
                          â”‚    â”‚Persistence  â”‚
                          â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                          â””â”€â”€â”€â–¶â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                               â”‚   åä½œåŒæ­¥   â”‚
                               â”‚Collaborationâ”‚
                               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 3. æ’ä»¶æ¶æ„ (Plugin Architecture)
```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚         æ’ä»¶ç®¡ç†å™¨               â”‚
                    â”‚      Plugin Manager            â”‚
                    â”‚                                â”‚
                    â”‚ â€¢ æ’ä»¶æ³¨å†Œ                      â”‚
                    â”‚ â€¢ ç”Ÿå‘½å‘¨æœŸç®¡ç†                   â”‚
                    â”‚ â€¢ ä¾èµ–è§£æ                      â”‚
                    â”‚ â€¢ ä¼˜å…ˆçº§æ’åº                    â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                           â”‚                           â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
â”‚   çŠ¶æ€æ’ä»¶     â”‚        â”‚    ä¸­é—´ä»¶æ’ä»¶      â”‚        â”‚   æ‰©å±•æ’ä»¶     â”‚
â”‚ State Plugin  â”‚        â”‚ Middleware Plugin â”‚        â”‚Extension Pluginâ”‚
â”‚               â”‚        â”‚                   â”‚        â”‚               â”‚
â”‚ â€¢ çŠ¶æ€å­—æ®µ     â”‚        â”‚ â€¢ è¯·æ±‚æ‹¦æˆª         â”‚        â”‚ â€¢ èŠ‚ç‚¹ç±»å‹     â”‚
â”‚ â€¢ èµ„æºç®¡ç†     â”‚        â”‚ â€¢ å“åº”å¤„ç†         â”‚        â”‚ â€¢ æ ‡è®°ç±»å‹     â”‚
â”‚ â€¢ äº‹åŠ¡å¤„ç†     â”‚        â”‚ â€¢ æ—¥å¿—è®°å½•         â”‚        â”‚ â€¢ æ¨¡å¼éªŒè¯     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ’ä»¶é—´æ•°æ®ä¾èµ–æµ (Plugin Data Dependency Flow):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          æ’ä»¶é—´äº‹åŠ¡æµè½¬æœºåˆ¶                                      â”‚
â”‚                                                                                 â”‚
â”‚  åˆå§‹äº‹åŠ¡ â†’ æ’ä»¶ A â†’ æ–°äº‹åŠ¡â‚ â†’ æ’ä»¶ B â†’ æ–°äº‹åŠ¡â‚‚ â†’ æ’ä»¶ C                         â”‚
â”‚                                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” 1.è®¡ç®—å®Œæˆ  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” 2.éªŒè¯å®Œæˆ  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  æ’ä»¶ A     â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚  æ’ä»¶ B     â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚  æ’ä»¶ C     â”‚          â”‚
â”‚  â”‚(è®¡ç®—æ’ä»¶)    â”‚ æäº¤æ–°äº‹åŠ¡   â”‚ (éªŒè¯æ’ä»¶)   â”‚ æäº¤æ–°äº‹åŠ¡   â”‚ (æ±‡æ€»æ’ä»¶)   â”‚          â”‚
â”‚  â”‚Priority: 10 â”‚             â”‚Priority: 20 â”‚             â”‚Priority: 30 â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚        â–²                           â–²                           â–²                 â”‚
â”‚        â”‚                           â”‚                           â”‚                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ åŸå§‹äº‹åŠ¡      â”‚          â”‚ é€šçŸ¥äº‹åŠ¡â‚     â”‚          â”‚ é€šçŸ¥äº‹åŠ¡â‚‚     â”‚            â”‚
â”‚  â”‚ meta:        â”‚          â”‚ meta:        â”‚          â”‚ meta:        â”‚            â”‚
â”‚  â”‚"nodes_to_    â”‚          â”‚"price_calc_  â”‚          â”‚"validation_  â”‚            â”‚
â”‚  â”‚ calculate"   â”‚          â”‚ completed"   â”‚          â”‚ completed"   â”‚            â”‚
â”‚  â”‚              â”‚          â”‚"calculation_ â”‚          â”‚"validation_  â”‚            â”‚
â”‚  â”‚              â”‚          â”‚ results"     â”‚          â”‚ results"     â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                                                 â”‚
â”‚  å…³é”®æœºåˆ¶:                                                                       â”‚
â”‚  â€¢ æ’ä»¶ä¸»åŠ¨æäº¤æ–°äº‹åŠ¡: runtime.dispatch_flow(new_transaction)                     â”‚
â”‚  â€¢ Meta ä¼ é€’è®¡ç®—ç»“æœ: transaction.set_meta("results", data)                      â”‚
â”‚  â€¢ Resource Table æŒä¹…åŒ–: resource_manager.add(key, value)                     â”‚
â”‚  â€¢ äº‹åŠ¡é“¾å¼è§¦å‘: Aå®Œæˆâ†’é€šçŸ¥Bâ†’Bå®Œæˆâ†’é€šçŸ¥Câ†’Cå®Œæˆ                                    â”‚
â”‚                                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚                    äº‹åŠ¡æ—¶åºå›¾                                            â”‚    â”‚
â”‚  â”‚                                                                         â”‚    â”‚
â”‚  â”‚  æ—¶é—´è½´   æ’ä»¶A          æ’ä»¶B          æ’ä»¶C                              â”‚    â”‚
â”‚  â”‚    â”‚      â”‚              â”‚              â”‚                              â”‚    â”‚
â”‚  â”‚    â–¼      â”‚              â”‚              â”‚                              â”‚    â”‚
â”‚  â”‚   T1   â–¶ å¤„ç†åŸå§‹äº‹åŠ¡      â”‚              â”‚                              â”‚    â”‚
â”‚  â”‚   T2     â”‚ â–¶ æäº¤é€šçŸ¥äº‹åŠ¡â‚  â”‚              â”‚                              â”‚    â”‚
â”‚  â”‚   T3     â”‚              â–¶ æ”¶åˆ°é€šçŸ¥äº‹åŠ¡â‚   â”‚                              â”‚    â”‚
â”‚  â”‚   T4     â”‚              â”‚ â–¶ æäº¤é€šçŸ¥äº‹åŠ¡â‚‚  â”‚                              â”‚    â”‚
â”‚  â”‚   T5     â”‚              â”‚              â–¶ æ”¶åˆ°é€šçŸ¥äº‹åŠ¡â‚‚                   â”‚    â”‚
â”‚  â”‚   T6     â”‚              â”‚              â”‚ â–¶ ç”Ÿæˆæœ€ç»ˆç»“æœ                  â”‚    â”‚
â”‚  â”‚                                                                         â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å…³é”®æ¶æ„åŸåˆ™

#### 1. ä¸å¯å˜æ€§ (Immutability)
- **ç»“æ„å…±äº«**: ä½¿ç”¨ `im-rs` å®ç°é«˜æ•ˆçš„ä¸å¯å˜æ•°æ®ç»“æ„
- **å†™æ—¶å¤åˆ¶**: åªæœ‰å˜æ›´éƒ¨åˆ†æ‰ä¼šåˆ›å»ºæ–°çš„æ•°æ®ç»“æ„
- **å¹¶å‘å®‰å…¨**: å¤©ç„¶æ”¯æŒå¤šçº¿ç¨‹å¹¶å‘è®¿é—®

#### 2. å•å‘æ•°æ®æµ (Unidirectional Data Flow)
```
å‰ç«¯ Frontend                     Rust åç«¯ Backend
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    IPC invoke    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ User Action â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶  â”‚ Transaction â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â–²                                 â”‚
      â”‚                                 â–¼
      â”‚                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚                         â”‚    State    â”‚
      â”‚                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚                                 â”‚
      â”‚                                 â–¼
      â”‚          IPC emit/event  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚   Events    â”‚
                                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 3. ç»„åˆä¼˜äºç»§æ‰¿ (Composition over Inheritance)
- **ç‰¹å¾ç»„åˆ**: ä½¿ç”¨ Rust trait ç³»ç»Ÿå®ç°è¡Œä¸ºç»„åˆ
- **æ’ä»¶ç³»ç»Ÿ**: é€šè¿‡æ’ä»¶åŠ¨æ€æ‰©å±•åŠŸèƒ½
- **ä¸­é—´ä»¶é“¾**: å¯ç»„åˆçš„å¤„ç†ç®¡é“

#### 4. ä¾èµ–æ³¨å…¥ (Dependency Injection)
- **èµ„æºç®¡ç†**: é€šè¿‡èµ„æºè¡¨ç®¡ç†ä¾èµ–
- **æ’ä»¶ä¾èµ–**: è‡ªåŠ¨è§£ææ’ä»¶é—´ä¾èµ–å…³ç³»
- **é…ç½®æ³¨å…¥**: è¿è¡Œæ—¶é…ç½®æ³¨å…¥

## ä¾èµ–é…ç½®

### Cargo.toml ä¾èµ–å£°æ˜

```toml
[package]
name = "your-project"
version = "0.1.0"
edition = "2021"

[dependencies]
# æ ¸å¿ƒæ¡†æ¶
moduforge-core = "0.4.12"        # å¼‚æ­¥è¿è¡Œæ—¶ã€äº‹ä»¶ç³»ç»Ÿã€æ‰©å±•ç®¡ç†
moduforge-model = "0.4.12"       # æ•°æ®æ¨¡å‹ - èŠ‚ç‚¹ã€æ ‡è®°ã€å±æ€§ã€æ¨¡å¼
moduforge-state = "0.4.12"       # çŠ¶æ€ç®¡ç†ã€äº‹åŠ¡ã€æ’ä»¶ã€èµ„æºç®¡ç†
moduforge-transform = "0.4.12"   # æ•°æ®è½¬æ¢æ“ä½œå’Œäº‹åŠ¡æ­¥éª¤

# è§„åˆ™å¼•æ“ç³»ç»Ÿ
moduforge-engine = "0.4.12"      # åŸºäº GoRules JDM æ ‡å‡†çš„ä¸šåŠ¡è§„åˆ™å¼•æ“
moduforge-expression = "0.4.12"  # é«˜æ€§èƒ½è¡¨è¾¾å¼è¯­è¨€ï¼Œæ”¯æŒ WASM
moduforge-template = "0.4.12"    # æ¨¡æ¿æ¸²æŸ“ç³»ç»Ÿ

# åä½œä¸æ•°æ®
moduforge-collaboration = "0.4.12"        # ä½¿ç”¨ Yrs CRDT çš„å®æ—¶åä½œç¼–è¾‘
moduforge-collaboration-client = "0.4.12" # å®¢æˆ·ç«¯åä½œå·¥å…·
moduforge-file = "0.4.12"                 # æ–‡æ¡£åºåˆ—åŒ–/ååºåˆ—åŒ– (JSON, CBOR, MessagePack)
moduforge-search = "0.4.12"               # æœç´¢ç´¢å¼•å’ŒæŸ¥è¯¢åŠŸèƒ½
moduforge-persistence = "0.4.12"          # æ•°æ®æŒä¹…åŒ–å’Œæ¢å¤æœºåˆ¶

# å¼€å‘å·¥å…·
moduforge-macro = "0.4.12"       # èŠ‚ç‚¹ã€æ’ä»¶ã€æ‰©å±•çš„è¿‡ç¨‹å®
moduforge-derive = "0.4.12"      # ä¾èµ–æ³¨å…¥çš„è¿‡ç¨‹å®

# å…¶ä»–å¿…éœ€ä¾èµ–
tokio = { version = "1", features = ["full"] }
anyhow = "1"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
lazy_static = "1.4"   # ç”¨äºé™æ€èŠ‚ç‚¹å’Œæ ‡è®°å®šä¹‰
async-trait = "0.1"   # ç”¨äºå¼‚æ­¥ trait å®ç°
tracing = "0.1"       # æ—¥å¿—ç³»ç»Ÿ
tracing-subscriber = "0.3"  # æ—¥å¿—è®¢é˜…å™¨

# Tauri æ¡Œé¢åº”ç”¨å¼€å‘ (å¯é€‰)
tauri = { version = "1.0", features = ["api-all"] }
tauri-build = { version = "1.0", features = [] }
```

### å¯é€‰ä¾èµ–ç»„åˆ

æ ¹æ®é¡¹ç›®éœ€æ±‚é€‰æ‹©åˆé€‚çš„ä¾èµ–ç»„åˆï¼š

```toml
# æœ€å°æ ¸å¿ƒ - åŸºç¡€æ–‡æ¡£å¤„ç†
[dependencies]
moduforge-core = "0.4.12"
moduforge-model = "0.4.12"
moduforge-state = "0.4.12"

# è§„åˆ™å¼•æ“ - ä¸šåŠ¡é€»è¾‘å¤„ç†
[dependencies]
moduforge-engine = "0.4.12"
moduforge-expression = "0.4.12"

# åä½œç³»ç»Ÿ - å®æ—¶å¤šç”¨æˆ·ç¼–è¾‘
[dependencies]
moduforge-collaboration = "0.4.12"
moduforge-collaboration-client = "0.4.12"

# æ•°æ®å¤„ç† - å®Œæ•´çš„æ•°æ®ç®¡é“
[dependencies]
moduforge-file = "0.4.12"
moduforge-search = "0.4.12"
moduforge-persistence = "0.4.12"

# æ¡Œé¢åº”ç”¨ - Tauri é›†æˆ
[dependencies]
moduforge-core = "0.4.12"
moduforge-model = "0.4.12"
moduforge-state = "0.4.12"
tauri = { version = "1.0", features = ["api-all"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

[build-dependencies]
tauri-build = { version = "1.0", features = [] }
```

## å¸¸ç”¨å¯¼å…¥

```rust
// æ ¸å¿ƒåŠŸèƒ½
use mf_core::{Runtime, Config, Event, Extension};
use mf_model::{Node, Mark, Attrs, Schema, Tree};
use mf_state::{State, Transaction, Plugin};
use mf_transform::{AddNodeStep, RemoveNodeStep, UpdateAttrsStep};

// è§„åˆ™å¼•æ“
use mf_engine::{Engine, Decision};
use mf_expression::{Expression, Variable};

// åä½œåŠŸèƒ½
use mf_collaboration::{SyncService, YrsManager};
use mf_collaboration_client::{CollaborationClient, Mapping};

// æ–‡ä»¶å’ŒæŒä¹…åŒ–
use mf_file::{Document, ZipDocWriter, ZipDocReader};
use mf_persistence::{SqlitePersistence, RecoveryManager};

// æœç´¢åŠŸèƒ½
use mf_search::{SearchService, Indexer, Query};

// å®
use mf_macro::{Node, Plugin, Extension};

// é”™è¯¯å¤„ç†
use anyhow::{Result, Context};
```

## åŸºç¡€ä½¿ç”¨æ¨¡å¼

### 1. èŠ‚ç‚¹å®šä¹‰ (ä½¿ç”¨å®ç®€åŒ–å®šä¹‰)

```rust
use lazy_static::lazy_static;
use mf_core::node::Node;
use mf_macro::node;

// ä½¿ç”¨ node! å®å®šä¹‰èŠ‚ç‚¹
lazy_static! {
    // å®šä¹‰å•ä»·æ„æˆèŠ‚ç‚¹
    pub static ref DJGC: Node = node!(
        "djgc",           // èŠ‚ç‚¹åç§°
        "å•ä»·æ„æˆ",        // èŠ‚ç‚¹æè¿°
        "",               // èŠ‚ç‚¹å†…å®¹æ¨¡å¼
        "value" => "".into()  // é»˜è®¤å±æ€§
    );
    
    // å®šä¹‰å•ä»·æ„æˆè¡ŒèŠ‚ç‚¹
    pub static ref DJGC_NODE: Node = node!(
        "djgcRowNode",
        "å•ä»·æ„æˆè¡ŒèŠ‚ç‚¹",
        "",
        "qfCode" => "".into(),
        "type" => "".into(),
        "code" => "".into(),
        "caculateBase" => "".into(),
        "desc" => "".into(),
        "rate" => "".into(),
        "price" => 0.into()
    );
}

// æ„å»ºèŠ‚ç‚¹é›†åˆçš„å‡½æ•°
pub fn init_nodes() -> Vec<Node> {
    let mut nodes = vec![DJGC_NODE.clone()];
    let mut djgc = DJGC.clone();
    djgc.set_content("djgcRowNode+");  // è®¾ç½®å†…å®¹æ¨¡å¼ï¼šä¸€ä¸ªæˆ–å¤šä¸ª djgcRowNode
    nodes.push(djgc);
    nodes
}
```

### 2. æ ‡è®°å®šä¹‰ (Mark)

```rust
use lazy_static::lazy_static;
use mf_core::mark::Mark;
use mf_macro::mark;

pub const BG_COLOR_STR: &str = "bgColor";
pub const FOOTNOTE_STR: &str = "footnote";

lazy_static! {
    // å®šä¹‰èƒŒæ™¯é¢œè‰²æ ‡è®°
    pub static ref BG_COLOR: Mark = mark!(
        BG_COLOR_STR,
        "èƒŒæ™¯é¢œè‰²",
        "value" => "#ffffff".into()
    );
    
    // å®šä¹‰è„šæ³¨æ ‡è®°
    pub static ref FOOTNOTE: Mark = mark!(
        FOOTNOTE_STR,
        "è„šæ³¨",
        "value" => "".into()
    );
}
```

### 3. ä¸­é—´ä»¶ç¼–å†™

```rust
use std::sync::Arc;
use async_trait::async_trait;
use mf_core::{middleware::Middleware, ForgeResult};
use mf_state::{State, Transaction};

/// æ”¶é›†åˆ†éƒ¨åˆ†é¡¹æªæ–½é¡¹ç›®æ±‡æ€»ä¸­é—´ä»¶
/// å½“ç¼–è¾‘åŒºåˆ†éƒ¨åˆ†é¡¹æªæ–½é¡¹ç›®èŠ‚ç‚¹æ›´æ–°åéœ€è¦æ”¶é›†æ±‡æ€»
#[derive(Debug)]
pub struct CollectFbfxCsxmMiddleware;

#[async_trait]
impl Middleware for CollectFbfxCsxmMiddleware {
    /// è¿”å›ä¸­é—´ä»¶çš„åç§°
    fn name(&self) -> String {
        "collect_fbfx_csxm".to_string()
    }

    /// åœ¨æ ¸å¿ƒåˆ†å‘ä¹‹åå¤„ç†ç»“æœ
    /// è¿”å›ä¸€ä¸ªå¯èƒ½åŒ…å«éœ€è¦é¢å¤–å¤„ç†çš„äº‹åŠ¡çš„ MiddlewareResult
    async fn after_dispatch(
        &self,
        _state: Option<Arc<State>>,
        transactions: &[Transaction],
    ) -> ForgeResult<Option<Transaction>> {
        println!("åˆ†éƒ¨åˆ†é¡¹æªæ–½é¡¹ç›®æ±‡æ€»");
        
        for tr in transactions {
            // æ£€æŸ¥äº‹åŠ¡å…ƒæ•°æ®ä¸­æ˜¯å¦åŒ…å«å®šé¢ ID
            if let Some(de_ids) = tr.get_meta::<Vec<String>>("de_ids") {
                // æ±‡æ€»å¯¹åº”çš„å®šé¢ä»·æ ¼å‘ä¸Šæ±‡æ€»
                // è¿™é‡Œå¯ä»¥å®ç°å…·ä½“çš„æ±‡æ€»é€»è¾‘
                println!("å¤„ç†å®šé¢æ±‡æ€»: {:?}", de_ids);
            }
        }
        
        // è¿”å› None è¡¨ç¤ºä¸éœ€è¦é¢å¤–çš„äº‹åŠ¡
        // è¿”å› Some(transaction) å¯ä»¥è§¦å‘é¢å¤–çš„çŠ¶æ€æ›´æ–°
        Ok(None)
    }
}
```

### 4. æ’ä»¶ç¼–å†™ (StateField)

```rust
use std::sync::Arc;
use async_trait::async_trait;
use mf_model::{attrs::Attrs, mark::Mark, node::Node, NodeId};
use mf_state::{
    plugin::StateField, resource::Resource, State, StateConfig, Transaction,
};
use mf_transform::{
    attr_step::AttrStep,
    mark_step::{AddMarkStep, RemoveMarkStep},
    node_step::{AddNodeStep, RemoveNodeStep},
};
use serde::{Deserialize, Serialize};

// å®šä¹‰å¢é‡æ•°æ®èµ„æº
pub struct IncState;
impl Resource for IncState {}

// å®šä¹‰æ“ä½œç±»å‹
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub enum Operation {
    RemoveMark(NodeId, Vec<String>),
    AddMark(NodeId, Vec<Mark>),
    UpdateAttrs(NodeId, Attrs),
    UpdateNode(Vec<Arc<Node>>),
    RemoveNode(Vec<NodeId>),
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Operations(pub Vec<Operation>);
impl Resource for Operations {}

/// å¢é‡æ•°æ®çŠ¶æ€å­—æ®µç®¡ç†å™¨
#[derive(Debug)]
pub struct IncStateField;

const INC_DATA_KEY: &str = "inc_data";

impl IncStateField {
    /// æ”¶é›†å¢é‡çš„æ•°æ®æ›´æ–°
    pub fn collect_tr(tr: &Transaction, new_state: &State) {
        if tr.steps.is_empty() {
            return;
        }
        
        let manager = new_state.resource_manager();
        let mut operations: Vec<Operation> = Vec::new();

        // éå†äº‹åŠ¡æ­¥éª¤ï¼Œæ”¶é›†å¢é‡æ•°æ®
        for (index, step) in tr.steps.iter().enumerate() {
            // æ·»åŠ èŠ‚ç‚¹
            if let Some(add_step) = step.downcast_ref::<AddNodeStep>() {
                let mut node_ids = Vec::new();
                for node_enum in add_step.nodes.iter() {
                    node_ids.extend(AddNodeStep::collect_node_ids(node_enum));
                }
                
                let mut nodes = Vec::new();
                for node_id in node_ids.iter() {
                    if let Some(node) = tr.doc().get_node(node_id) {
                        nodes.push(node);
                    }
                }
                
                if !nodes.is_empty() {
                    operations.push(Operation::UpdateNode(nodes));
                }
            }
            
            // åˆ é™¤èŠ‚ç‚¹
            if let Some(_) = step.downcast_ref::<RemoveNodeStep>() {
                let mut node_ids = Vec::new();
                // è·å–åå‘æ“ä½œçš„èŠ‚ç‚¹ ID
                if let Some(add_step) = tr.invert_steps[index].downcast_ref::<AddNodeStep>() {
                    for node_enum in add_step.nodes.iter() {
                        node_ids.extend(AddNodeStep::collect_node_ids(node_enum));
                    }
                }
                
                if !node_ids.is_empty() {
                    operations.push(Operation::RemoveNode(node_ids));
                }
            }
            
            // æ›´æ–°èŠ‚ç‚¹å±æ€§
            if let Some(attr_step) = step.downcast_ref::<AttrStep>() {
                if let Some(node) = tr.doc().get_node(&attr_step.id) {
                    operations.push(Operation::UpdateAttrs(
                        attr_step.id.clone(),
                        node.attrs.clone(),
                    ));
                }
            }
            
            // æ·»åŠ æ ‡è®°
            if let Some(add_mark_step) = step.downcast_ref::<AddMarkStep>() {
                if tr.doc().get_node(&add_mark_step.id).is_some() {
                    operations.push(Operation::AddMark(
                        add_mark_step.id.clone(),
                        add_mark_step.marks.clone(),
                    ));
                }
            }
            
            // åˆ é™¤æ ‡è®°
            if let Some(remove_mark_step) = step.downcast_ref::<RemoveMarkStep>() {
                if tr.doc().get_node(&remove_mark_step.id).is_some() {
                    operations.push(Operation::RemoveMark(
                        remove_mark_step.id.clone(),
                        remove_mark_step.mark_types.clone(),
                    ));
                }
            }
        }
        
        // ä¿å­˜å¢é‡æ•°æ®åˆ°èµ„æºè¡¨
        if !operations.is_empty() {
            manager
                .resource_table
                .add(INC_DATA_KEY.to_string(), Operations(operations));
        }
    }
}

#[async_trait]
impl StateField for IncStateField {
    async fn init(
        &self,
        _config: &StateConfig,
        _instance: &State,
    ) -> Arc<dyn Resource> {
        Arc::new(IncState)
    }
    
    async fn apply(
        &self,
        tr: &Transaction,
        value: Arc<dyn Resource>,
        _old_state: &State,
        new_state: &State,
    ) -> Arc<dyn Resource> {
        IncStateField::collect_tr(tr, new_state);
        value
    }
}
```

### 4.5. æ’ä»¶é—´æ•°æ®ä¾èµ–ç®¡ç† (ä½¿ç”¨ Meta æµè½¬)

å½“å¤šä¸ªæ’ä»¶éœ€è¦åä½œæ—¶ï¼Œæ¨èä½¿ç”¨äº‹åŠ¡çš„ meta æ•°æ®è¿›è¡Œæ’ä»¶é—´çš„æ•°æ®ä¼ é€’å’Œä¾èµ–ç®¡ç†ã€‚

#### æ’ä»¶ä¾èµ–åœºæ™¯ç¤ºä¾‹

```rust
use std::sync::Arc;
use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use mf_state::{plugin::StateField, resource::Resource, State, Transaction};

// å®šä¹‰æ’ä»¶é—´ä¼ é€’çš„æ•°æ®ç»“æ„
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct CalculationResult {
    pub node_id: String,
    pub calculated_value: f64,
    pub formula_used: String,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct ValidationResult {
    pub node_id: String,
    pub is_valid: bool,
    pub error_messages: Vec<String>,
    pub validated_by: String,
}

// ================================================================================
// æ’ä»¶ A: ä»·æ ¼è®¡ç®—æ’ä»¶
// ================================================================================

/// StateField: ä¸“é—¨ä¸ºä»·æ ¼è®¡ç®—æ’ä»¶å®šä¹‰ç‹¬ç«‹çš„çŠ¶æ€å­˜å‚¨
/// ç›®çš„: ç®¡ç†ç¼“å­˜æ•°æ®ã€ç»Ÿè®¡ä¿¡æ¯ç­‰éœ€è¦æŒä¹…åŒ–çš„æ’ä»¶çŠ¶æ€
#[derive(Debug)]
pub struct PriceCalculationStateField;

#[async_trait]
impl StateField for PriceCalculationStateField {
    /// åˆå§‹åŒ–æ’ä»¶çš„ç‹¬ç«‹çŠ¶æ€ç©ºé—´
    async fn init(&self, _config: &StateConfig, _instance: &State) -> Arc<dyn Resource> {
        Arc::new(PriceCalculationState {
            calculation_cache: HashMap::new(),
            total_calculations: 0,
            last_calculation_time: None,
        })
    }
    
    /// å¤„ç†äº‹åŠ¡ï¼Œæ›´æ–°æ’ä»¶çŠ¶æ€ï¼ˆçº¯çŠ¶æ€ç®¡ç†ï¼Œä¸äº§ç”Ÿæ–°äº‹åŠ¡ï¼‰
    async fn apply(
        &self,
        tr: &Transaction,
        value: Arc<dyn Resource>,
        _old_state: &State,
        new_state: &State,
    ) -> Arc<dyn Resource> {
        let mut state = value.downcast_ref::<PriceCalculationState>()
            .expect("çŠ¶æ€ç±»å‹é”™è¯¯")
            .clone();
            
        // åªè´Ÿè´£çŠ¶æ€å˜æ›´ï¼Œæ›´æ–°ç»Ÿè®¡ä¿¡æ¯å’Œç¼“å­˜
        if let Some(node_ids) = tr.get_meta::<Vec<String>>("nodes_to_calculate") {
            // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
            state.total_calculations += 1;
            state.last_calculation_time = Some(chrono::Utc::now());
            
            // ç¼“å­˜è®¡ç®—ç»“æœï¼ˆå¦‚æœéœ€è¦çš„è¯ï¼‰
            for node_id in node_ids {
                if let Some(node) = new_state.doc().get_node(&node_id) {
                    let calculated_value = self.calculate_price(&node).await;
                    state.calculation_cache.insert(node_id.clone(), calculated_value);
                }
            }
        }
        
        Arc::new(state)
    }
}

impl PriceCalculationStateField {
    async fn calculate_price(&self, node: Arc<Node>) -> f64 {
        // å…·ä½“çš„ä»·æ ¼è®¡ç®—é€»è¾‘
        let base_price = node.attrs.get("base_price")
            .and_then(|v| v.as_f64())
            .unwrap_or(0.0);
        let quantity = node.attrs.get("quantity")
            .and_then(|v| v.as_f64())
            .unwrap_or(1.0);
        let rate = node.attrs.get("rate")
            .and_then(|v| v.as_f64())
            .unwrap_or(1.0);
        
        base_price * quantity * rate
    }
}

/// PluginTrait: æ’ä»¶çš„ä¸šåŠ¡é€»è¾‘å±‚ï¼Œè´Ÿè´£å†³å®šä½•æ—¶äº§ç”Ÿæ–°äº‹åŠ¡
/// ç›®çš„: æ ¹æ®ä¸šåŠ¡éœ€æ±‚åˆ¤æ–­æ˜¯å¦éœ€è¦é€šçŸ¥å…¶ä»–æ’ä»¶
#[derive(Debug)]
pub struct PriceCalculationPlugin;

#[async_trait]
impl PluginTrait for PriceCalculationPlugin {
    /// ä¸šåŠ¡é€»è¾‘ï¼šåˆ¤æ–­ä½•æ—¶éœ€è¦äº§ç”Ÿæ–°äº‹åŠ¡
    /// âœ… ä½¿ç”¨ Transaction Meta æ–¹å¼ - ç›´æ¥ä»äº‹åŠ¡ä¸­è®¡ç®—å’Œä¼ é€’æ•°æ®
    async fn append_transaction(
        &self,
        transactions: &[Transaction],
        old_state: &State,
        new_state: &State,
    ) -> StateResult<Option<Transaction>> {
        // ğŸ”„ ç›´æ¥ä» transactions å‚æ•°ä¸­æŸ¥æ‰¾è§¦å‘æ¡ä»¶
        for transaction in transactions {
            if let Some(node_ids) = transaction.get_meta::<Vec<String>>("nodes_to_calculate") {
                println!("æ’ä»¶ A æ£€æµ‹åˆ°è®¡ç®—è¯·æ±‚: {:?}", node_ids);
                
                // ç›´æ¥æ‰§è¡Œè®¡ç®—ï¼Œä¸å­˜å‚¨åˆ°çŠ¶æ€ä¸­ï¼ˆé™¤ééœ€è¦ç¼“å­˜ï¼‰
                let mut calculation_results = Vec::new();
                
                for node_id in node_ids {
                    if let Some(node) = new_state.doc().get_node(&node_id) {
                        let calculated_value = self.calculate_price(&node).await;
                        
                        let result = CalculationResult {
                            node_id: node_id.clone(),
                            calculated_value,
                            formula_used: "base_price * quantity * rate".to_string(),
                            timestamp: chrono::Utc::now(),
                        };
                        
                        calculation_results.push(result);
                    }
                }
                
                // ä¸šåŠ¡è§„åˆ™ï¼šåªæœ‰å½“è®¡ç®—å€¼åœ¨åˆç†èŒƒå›´å†…æ‰é€šçŸ¥ä¸‹æ¸¸
                let valid_results: Vec<_> = calculation_results
                    .iter()
                    .filter(|result| result.calculated_value > 0.0 && result.calculated_value < 10000.0)
                    .cloned()
                    .collect();
                
                if !valid_results.is_empty() {
                    // âœ… æ­£ç¡®æ–¹å¼ï¼šä½¿ç”¨ new_state åˆ›å»ºäº‹åŠ¡
                    let mut notification_transaction = new_state.tr();
                    
                    // è®¾ç½®é€šçŸ¥æ ‡è¯†
                    notification_transaction.set_meta("price_calculation_completed", true);
                    
                    // ç›´æ¥ä¼ é€’è®¡ç®—ç»“æœï¼ˆæ¨èæ–¹å¼ï¼‰
                    notification_transaction.set_meta("calculation_results", valid_results.clone());
                    
                    // ä¸šåŠ¡åˆ¤æ–­ï¼šå¦‚æœè®¡ç®—é‡å¤§ï¼Œè®¾ç½®æ‰¹é‡å¤„ç†æ ‡è¯†
                    if valid_results.len() > 10 {
                        notification_transaction.set_meta("batch_processing_required", true);
                    }
                    
                    println!("æ’ä»¶ A å®Œæˆè®¡ç®—ï¼Œé€šè¿‡ meta ä¼ é€’ {} ä¸ªç»“æœ", valid_results.len());
                    return Ok(Some(notification_transaction));
                }
            }
        }
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦å®šæœŸæ±‡æ€»ï¼ˆè¿™ç§æƒ…å†µéœ€è¦è®¿é—®çŠ¶æ€ï¼‰
        if let Some(calc_state) = new_state.get_field("price_calculation")
            .and_then(|state| state.downcast_ref::<PriceCalculationState>()) 
        {
            if let Some(last_time) = calc_state.last_calculation_time {
                let duration = chrono::Utc::now().signed_duration_since(last_time);
                if duration.num_hours() >= 1 && calc_state.total_calculations >= 100 {
                    let mut summary_transaction = new_state.tr();
                    summary_transaction.set_meta("periodic_summary_required", true);
                    summary_transaction.set_meta("calculation_count", calc_state.total_calculations);
                    
                    println!("æ’ä»¶ A è§¦å‘å®šæœŸæ±‡æ€»");
                    return Ok(Some(summary_transaction));
                }
            }
        }
        
        Ok(None)
    }
}

impl PriceCalculationPlugin {
    async fn calculate_price(&self, node: Arc<Node>) -> f64 {
        // å…·ä½“çš„ä»·æ ¼è®¡ç®—é€»è¾‘
        let base_price = node.attrs.get("base_price")
            .and_then(|v| v.as_f64())
            .unwrap_or(0.0);
        let quantity = node.attrs.get("quantity")
            .and_then(|v| v.as_f64())
            .unwrap_or(1.0);
        let rate = node.attrs.get("rate")
            .and_then(|v| v.as_f64())
            .unwrap_or(1.0);
        
        base_price * quantity * rate
    }
}

/// ä»·æ ¼è®¡ç®—æ’ä»¶çš„ç‹¬ç«‹çŠ¶æ€ç»“æ„
/// ä¸“æ³¨äºéœ€è¦æŒä¹…åŒ–çš„æ•°æ®ï¼šç¼“å­˜ã€ç»Ÿè®¡ä¿¡æ¯ç­‰
#[derive(Debug, Clone)]
pub struct PriceCalculationState {
    pub calculation_cache: HashMap<String, f64>,
    pub total_calculations: u64,
    pub last_calculation_time: Option<chrono::DateTime<chrono::Utc>>,
}
impl Resource for PriceCalculationState {}

// ================================================================================
// æ’ä»¶ B: æ•°æ®éªŒè¯æ’ä»¶ (ä¾èµ–äºæ’ä»¶ A çš„ç»“æœ)
// ================================================================================

/// StateField: ä¸“é—¨ä¸ºéªŒè¯æ’ä»¶å®šä¹‰ç‹¬ç«‹çš„çŠ¶æ€å­˜å‚¨
/// åªå­˜å‚¨éœ€è¦æŒä¹…åŒ–çš„éªŒè¯ç»Ÿè®¡ä¿¡æ¯
#[derive(Debug)]
pub struct ValidationStateField;

#[async_trait]
impl StateField for ValidationStateField {
    async fn init(&self, _config: &StateConfig, _instance: &State) -> Arc<dyn Resource> {
        Arc::new(ValidationState { 
            total_validations: 0,
            failed_validations: 0,
            last_validation_time: None,
        })
    }
    
    /// åªè´Ÿè´£æ›´æ–°éªŒè¯ç»Ÿè®¡ä¿¡æ¯ï¼Œä¸å¤„ç†ä¸šåŠ¡é€»è¾‘
    async fn apply(
        &self,
        tr: &Transaction,
        value: Arc<dyn Resource>,
        _old_state: &State,
        new_state: &State,
    ) -> Arc<dyn Resource> {
        let mut state = value.downcast_ref::<ValidationState>()
            .expect("çŠ¶æ€ç±»å‹é”™è¯¯")
            .clone();
            
        // åªæ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        if tr.has_meta("price_calculation_completed") {
            state.total_validations += 1;
            state.last_validation_time = Some(chrono::Utc::now());
            
            // å¦‚æœæœ‰éªŒè¯å¤±è´¥ï¼Œæ›´æ–°å¤±è´¥è®¡æ•°
            if let Some(validation_results) = tr.get_meta::<Vec<ValidationResult>>("validation_results") {
                let failures = validation_results.iter().filter(|r| !r.is_valid).count();
                state.failed_validations += failures as u64;
            }
        }
        
        Arc::new(state)
    }
}

/// PluginTrait: éªŒè¯æ’ä»¶çš„ä¸šåŠ¡é€»è¾‘
/// âœ… ä½¿ç”¨ Transaction Meta æ–¹å¼ - ç›´æ¥ä»äº‹åŠ¡ä¸­è·å–æ•°æ®å¹¶éªŒè¯
#[derive(Debug)]
pub struct ValidationPlugin;

#[async_trait]
impl PluginTrait for ValidationPlugin {
    /// ä¸šåŠ¡é€»è¾‘ï¼šä» transactions å‚æ•°ä¸­ç›´æ¥è·å–è®¡ç®—ç»“æœå¹¶è¿›è¡ŒéªŒè¯
    async fn append_transaction(
        &self,
        transactions: &[Transaction],
        old_state: &State,
        new_state: &State,
    ) -> StateResult<Option<Transaction>> {
        // ğŸ”„ ç›´æ¥ä» transactions å‚æ•°ä¸­æŸ¥æ‰¾è®¡ç®—å®Œæˆçš„äº‹åŠ¡
        for transaction in transactions {
            if transaction.has_meta("price_calculation_completed") {
                println!("æ’ä»¶ B æ£€æµ‹åˆ°ä»·æ ¼è®¡ç®—å®Œæˆ");
                
                // ç›´æ¥ä»äº‹åŠ¡ meta ä¸­è·å–è®¡ç®—ç»“æœ
                if let Some(calculation_results) = transaction.get_meta::<Vec<CalculationResult>>("calculation_results") {
                    println!("æ’ä»¶ B è·å–åˆ° {} ä¸ªè®¡ç®—ç»“æœï¼Œå¼€å§‹éªŒè¯", calculation_results.len());
                    
                    // ç›´æ¥å¯¹è®¡ç®—ç»“æœè¿›è¡ŒéªŒè¯ï¼Œä¸éœ€è¦å­˜å‚¨åˆ°çŠ¶æ€
                    let mut validation_results = Vec::new();
                    
                    for calc_result in calculation_results {
                        let validation_result = self.validate_calculation(&calc_result).await;
                        validation_results.push(validation_result);
                    }
                    
                    // âœ… æ­£ç¡®æ–¹å¼ï¼šä½¿ç”¨ new_state åˆ›å»ºäº‹åŠ¡
                    let mut notification_transaction = new_state.tr();
                    
                    // è®¾ç½®éªŒè¯å®Œæˆæ ‡è¯†
                    notification_transaction.set_meta("validation_completed", true);
                    
                    // ç›´æ¥ä¼ é€’éªŒè¯ç»“æœï¼ˆæ¨èæ–¹å¼ï¼‰
                    notification_transaction.set_meta("validation_results", validation_results.clone());
                    
                    // æ£€æŸ¥æ˜¯å¦æœ‰éªŒè¯å¤±è´¥
                    let has_failures = validation_results.iter().any(|v| !v.is_valid);
                    notification_transaction.set_meta("has_validation_failures", has_failures);
                    
                    if has_failures {
                        let failed_node_ids: Vec<String> = validation_results
                            .iter()
                            .filter(|r| !r.is_valid)
                            .map(|r| r.node_id.clone())
                            .collect();
                        notification_transaction.set_meta("failed_node_ids", failed_node_ids);
                    }
                    
                    println!("æ’ä»¶ B å®ŒæˆéªŒè¯ï¼Œé€šè¿‡ meta ä¼ é€’ {} ä¸ªéªŒè¯ç»“æœ", validation_results.len());
                    return Ok(Some(notification_transaction));
                }
            }
        }
        
        Ok(None)
    }
}

/// éªŒè¯æ’ä»¶çš„çŠ¶æ€æ•°æ® - åªå­˜å‚¨ç»Ÿè®¡ä¿¡æ¯
#[derive(Debug, Clone)]
pub struct ValidationState {
    pub total_validations: u64,
    pub failed_validations: u64,
    pub last_validation_time: Option<chrono::DateTime<chrono::Utc>>,
}
impl Resource for ValidationState {}

impl ValidationPlugin {
    async fn validate_calculation(&self, calc_result: &CalculationResult) -> ValidationResult {
        let mut errors = Vec::new();
        
        // éªŒè¯è®¡ç®—ç»“æœçš„åˆç†æ€§
        if calc_result.calculated_value < 0.0 {
            errors.push("è®¡ç®—å€¼ä¸èƒ½ä¸ºè´Ÿæ•°".to_string());
        }
        
        if calc_result.calculated_value > 1_000_000.0 {
            errors.push("è®¡ç®—å€¼è¶…å‡ºåˆç†èŒƒå›´".to_string());
        }
        
        // éªŒè¯å…¬å¼
        if calc_result.formula_used.is_empty() {
            errors.push("ç¼ºå°‘è®¡ç®—å…¬å¼".to_string());
        }
        
        ValidationResult {
            node_id: calc_result.node_id.clone(),
            is_valid: errors.is_empty(),
            error_messages: errors,
            validated_by: "ValidationPlugin".to_string(),
        }
    }
}

// ================================================================================
// æ’ä»¶ C: æ±‡æ€»æ’ä»¶ (ä¾èµ–äºæ’ä»¶ A å’Œ B çš„ç»“æœ)  
// ================================================================================

/// StateField: æ±‡æ€»æ’ä»¶çš„çŠ¶æ€å­˜å‚¨
#[derive(Debug)]
pub struct SummaryStateField;

#[async_trait]
impl StateField for SummaryStateField {
    async fn init(&self, _config: &StateConfig, _instance: &State) -> Arc<dyn Resource> {
        Arc::new(SummaryState {
            total_summaries: 0,
            last_summary_time: None,
        })
    }
    
    /// åªè´Ÿè´£æ›´æ–°æ±‡æ€»ç»Ÿè®¡ä¿¡æ¯
    async fn apply(
        &self,
        tr: &Transaction,
        value: Arc<dyn Resource>,
        _old_state: &State,
        new_state: &State,
    ) -> Arc<dyn Resource> {
        let mut state = value.downcast_ref::<SummaryState>()
            .expect("çŠ¶æ€ç±»å‹é”™è¯¯")
            .clone();
            
        // åªæ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        if tr.has_meta("validation_completed") {
            state.total_summaries += 1;
            state.last_summary_time = Some(chrono::Utc::now());
        }
        
        Arc::new(state)
    }
}

/// PluginTrait: æ±‡æ€»æ’ä»¶çš„ä¸šåŠ¡é€»è¾‘
/// âœ… ä½¿ç”¨ Transaction Meta æ–¹å¼ - ç›´æ¥ä»äº‹åŠ¡ä¸­è·å–æ‰€æœ‰å¿…è¦æ•°æ®
#[derive(Debug)]
pub struct SummaryPlugin;

#[async_trait]
impl PluginTrait for SummaryPlugin {
    /// ä¸šåŠ¡é€»è¾‘ï¼šä» transactions å‚æ•°ä¸­æ”¶é›†æ‰€æœ‰éœ€è¦çš„æ•°æ®å¹¶ç”Ÿæˆæ±‡æ€»
    async fn append_transaction(
        &self,
        transactions: &[Transaction],
        old_state: &State,
        new_state: &State,
    ) -> StateResult<Option<Transaction>> {
        // ğŸ”„ ç›´æ¥ä» transactions å‚æ•°ä¸­æŸ¥æ‰¾éªŒè¯å®Œæˆçš„äº‹åŠ¡
        let mut calculation_results = Vec::new();
        let mut validation_results = Vec::new();
        
        // éå†æ‰€æœ‰äº‹åŠ¡ï¼Œæ”¶é›†è®¡ç®—å’ŒéªŒè¯ç»“æœ
        for transaction in transactions {
            // æ”¶é›†è®¡ç®—ç»“æœ
            if transaction.has_meta("price_calculation_completed") {
                if let Some(calc_results) = transaction.get_meta::<Vec<CalculationResult>>("calculation_results") {
                    calculation_results.extend(calc_results);
                }
            }
            
            // æ”¶é›†éªŒè¯ç»“æœ
            if transaction.has_meta("validation_completed") {
                println!("æ’ä»¶ C æ£€æµ‹åˆ°éªŒè¯å®Œæˆ");
                
                if let Some(valid_results) = transaction.get_meta::<Vec<ValidationResult>>("validation_results") {
                    validation_results.extend(valid_results);
                    
                    // å¦‚æœæœ‰éªŒè¯ç»“æœï¼Œç”Ÿæˆæ±‡æ€»æŠ¥å‘Š
                    if !validation_results.is_empty() {
                        println!("æ’ä»¶ C å¼€å§‹ç”Ÿæˆæ±‡æ€»æŠ¥å‘Š");
                        
                        // ç›´æ¥ç”Ÿæˆæ±‡æ€»æŠ¥å‘Šï¼Œä¸éœ€è¦å­˜å‚¨ä¸­é—´çŠ¶æ€
                        let summary = self.create_summary_report(
                            &calculation_results, 
                            &validation_results
                        ).await;
                        
                        // âœ… æ­£ç¡®æ–¹å¼ï¼šä½¿ç”¨ new_state åˆ›å»ºäº‹åŠ¡
                        let mut notification_transaction = new_state.tr();
                        
                        // è®¾ç½®æ±‡æ€»å®Œæˆæ ‡è¯†
                        notification_transaction.set_meta("summary_completed", true);
                        
                        // ç›´æ¥ä¼ é€’æ±‡æ€»æŠ¥å‘Šï¼ˆæ¨èæ–¹å¼ï¼‰
                        notification_transaction.set_meta("summary_report", summary.clone());
                        notification_transaction.set_meta("workflow_completed", true);
                        
                        println!("æ’ä»¶ C å®Œæˆæ±‡æ€»ï¼Œé€šè¿‡ meta ä¼ é€’æ±‡æ€»æŠ¥å‘Š");
                        return Ok(Some(notification_transaction));
                    }
                }
            }
        }
        
        Ok(None)
    }
}

/// æ±‡æ€»æ’ä»¶çš„çŠ¶æ€æ•°æ® - åªå­˜å‚¨ç»Ÿè®¡ä¿¡æ¯
#[derive(Debug, Clone)]
pub struct SummaryState {
    pub total_summaries: u64,
    pub last_summary_time: Option<chrono::DateTime<chrono::Utc>>,
}
impl Resource for SummaryState {}

impl SummaryPlugin {
    async fn create_summary_report(
        &self, 
        calculations: &[CalculationResult], 
        validations: &[ValidationResult]
    ) -> SummaryReport {
        SummaryReport {
            total_calculations: calculations.len(),
            valid_calculations: validations.iter().filter(|v| v.is_valid).count(),
            invalid_calculations: validations.iter().filter(|v| !v.is_valid).count(),
            total_value: calculations.iter().map(|c| c.calculated_value).sum(),
            generated_at: chrono::Utc::now(),
        }
    }
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct SummaryReport {
    pub total_calculations: usize,
    pub valid_calculations: usize,
    pub invalid_calculations: usize,
    pub total_value: f64,
    pub generated_at: chrono::DateTime<chrono::Utc>,
}
impl Resource for SummaryReport {}
```

#### æ’ä»¶æ³¨å†Œå’Œä¼˜å…ˆçº§é…ç½®

```rust
/// é…ç½®æ’ä»¶çš„ä¾èµ–å…³ç³»å’Œæ‰§è¡Œé¡ºåº
/// âœ… ä½¿ç”¨ Transaction Meta æ–¹å¼çš„æ’ä»¶é…ç½®
pub fn init_dependent_extensions() -> Vec<Extensions> {
    let mut extensions = Vec::new();
    
    // åˆ›å»ºæ‰©å±•å®¹å™¨
    let mut extension = Extension::new();
    
    // æŒ‰ç…§ä¾èµ–å…³ç³»é…ç½®æ’ä»¶ä¼˜å…ˆçº§
    // æ•°å­—è¶Šå°ï¼Œä¼˜å…ˆçº§è¶Šé«˜ï¼ˆè¶Šæ—©æ‰§è¡Œï¼‰
    
    // æ’ä»¶ A: ä»·æ ¼è®¡ç®— (æœ€é«˜ä¼˜å…ˆçº§ï¼Œæœ€å…ˆæ‰§è¡Œ)
    let calc_plugin = Plugin::new(PluginSpec {
        key: ("price_calculation".to_string(), "ä»·æ ¼è®¡ç®—æ’ä»¶".to_string()),
        state_field: Some(Arc::new(PriceCalculationStateField)), // åªå­˜å‚¨ç¼“å­˜å’Œç»Ÿè®¡
        tr: Some(Arc::new(PriceCalculationPlugin)),              // é€šè¿‡ meta ä¼ é€’æ•°æ®
        priority: 10,  // æœ€é«˜ä¼˜å…ˆçº§
    });
    
    // æ’ä»¶ B: æ•°æ®éªŒè¯ (ä¾èµ–äºè®¡ç®—ç»“æœ)
    let validation_plugin = Plugin::new(PluginSpec {
        key: ("validation".to_string(), "æ•°æ®éªŒè¯æ’ä»¶".to_string()),
        state_field: Some(Arc::new(ValidationStateField)),  // åªå­˜å‚¨ç»Ÿè®¡ä¿¡æ¯
        tr: Some(Arc::new(ValidationPlugin)),               // ä» transactions è·å–æ•°æ®
        priority: 20,  // ä¸­ç­‰ä¼˜å…ˆçº§
    });
    
    // æ’ä»¶ C: æ±‡æ€»æŠ¥å‘Š (ä¾èµ–äºè®¡ç®—å’ŒéªŒè¯ç»“æœ)
    let summary_plugin = Plugin::new(PluginSpec {
        key: ("summary".to_string(), "æ±‡æ€»æŠ¥å‘Šæ’ä»¶".to_string()),
        state_field: Some(Arc::new(SummaryStateField)),  // åªå­˜å‚¨ç»Ÿè®¡ä¿¡æ¯
        tr: Some(Arc::new(SummaryPlugin)),               // ä» transactions æ”¶é›†æ‰€æœ‰æ•°æ®
        priority: 30,  // æœ€ä½ä¼˜å…ˆçº§ï¼Œæœ€åæ‰§è¡Œ
    });
    
    // æŒ‰é¡ºåºæ·»åŠ æ’ä»¶
    extension.add_plugin(Arc::new(calc_plugin));
    extension.add_plugin(Arc::new(validation_plugin));
    extension.add_plugin(Arc::new(summary_plugin));
    
    extensions.push(Extensions::E(extension));
    extensions
}

/// å®Œæ•´çš„æ’ä»¶ä¾èµ–æµç¨‹è¯´æ˜
/// 
/// 1. ç”¨æˆ·æäº¤åŸå§‹äº‹åŠ¡ï¼ŒåŒ…å« meta: "nodes_to_calculate"
/// 2. æ¡†æ¶æŒ‰ä¼˜å…ˆçº§é¡ºåºæ‰§è¡Œæ’ä»¶ï¼š
///    - PriceCalculationStateField.apply() å¤„ç†åŸå§‹äº‹åŠ¡ï¼Œæ‰§è¡Œè®¡ç®—
///    - PriceCalculationPlugin.append_transaction() è¿”å›é€šçŸ¥äº‹åŠ¡â‚
/// 3. æ¡†æ¶å¤„ç†é€šçŸ¥äº‹åŠ¡â‚ï¼š
///    - ValidationStateField.apply() æ¥æ”¶é€šçŸ¥äº‹åŠ¡â‚ï¼Œæ‰§è¡ŒéªŒè¯  
///    - ValidationPlugin.append_transaction() è¿”å›é€šçŸ¥äº‹åŠ¡â‚‚
/// 4. æ¡†æ¶å¤„ç†é€šçŸ¥äº‹åŠ¡â‚‚ï¼š
///    - SummaryStateField.apply() æ¥æ”¶é€šçŸ¥äº‹åŠ¡â‚‚ï¼Œç”Ÿæˆæ±‡æ€»
///    - SummaryPlugin.append_transaction() å¯é€‰æ‹©è¿”å›æœ€ç»ˆé€šçŸ¥
/// 
/// å…³é”®æœºåˆ¶ï¼š
/// - StateField.apply(): å¤„ç†çŠ¶æ€å˜æ›´ï¼Œå­˜å‚¨æ’ä»¶æ•°æ®
/// - PluginTrait.append_transaction(): æäº¤æ–°äº‹åŠ¡ï¼Œè§¦å‘ä¸‹æ¸¸æ’ä»¶
/// - Meta æ•°æ®: åœ¨äº‹åŠ¡é—´ä¼ é€’è½»é‡çº§ä¿¡æ¯
/// - Resource Table: å­˜å‚¨å¤æ‚çš„è®¡ç®—ç»“æœæ•°æ®
/// - Priority: æ§åˆ¶æ’ä»¶æ‰§è¡Œé¡ºåºï¼Œç¡®ä¿ä¾èµ–å…³ç³»æ­£ç¡®
```

#### Transaction Meta vs State å­˜å‚¨çš„è®¾è®¡æƒè¡¡

åŸºäºä½ çš„è§‚å¯Ÿï¼Œç¡®å®å­˜åœ¨ä¸€ä¸ªé‡è¦çš„æ¶æ„è®¾è®¡é—®é¢˜ï¼š**ä¸ºä»€ä¹ˆéœ€è¦åŒæ—¶ä½¿ç”¨ Transaction Meta å’Œ State å­˜å‚¨ï¼Ÿ**

```rust
// å…³é”®é—®é¢˜ï¼šappend_transaction å‚æ•°ä¸­å·²ç»æœ‰ transactions æ•°ç»„
async fn append_transaction(
    &self,
    transactions: &[Transaction],  // ğŸ‘ˆ å¯ä»¥ç›´æ¥è®¿é—®æ‰€æœ‰äº‹åŠ¡å’Œå…¶ meta
    old_state: &State,
    new_state: &State,
) -> StateResult<Option<Transaction>>
```

**è®¾è®¡æƒè¡¡åˆ†æ**ï¼š

1. **Transaction Meta: è½»é‡çº§äº‹åŠ¡é—´é€šä¿¡**
   ```rust
   // âœ… ä¼˜åŠ¿ï¼šç›´æ¥è®¿é—®ï¼Œæ— éœ€çŠ¶æ€æŸ¥æ‰¾
   if let Some(results) = transaction.get_meta::<Vec<CalculationResult>>("calculation_results") {
       // ç›´æ¥ä½¿ç”¨ meta ä¸­çš„æ•°æ®
   }
   
   // âŒ é™åˆ¶ï¼šæ•°æ®ç”Ÿå‘½å‘¨æœŸä»…é™äºäº‹åŠ¡é“¾æ‰§è¡ŒæœŸé—´
   ```

2. **State å­˜å‚¨: æŒä¹…åŒ–æ’ä»¶çŠ¶æ€**
   ```rust
   // âœ… ä¼˜åŠ¿ï¼šæ•°æ®åœ¨æ•´ä¸ªåº”ç”¨ç”Ÿå‘½å‘¨æœŸå†…æŒä¹…å­˜åœ¨
   let calc_state = new_state.get_field("price_calculation")
       .and_then(|state| state.downcast_ref::<PriceCalculationState>());
   
   // âœ… ä¼˜åŠ¿ï¼šæ”¯æŒå¤æ‚çš„çŠ¶æ€ç®¡ç†ï¼Œå¦‚ç¼“å­˜ã€ç»Ÿè®¡ã€å†å²è®°å½•
   ```

**æ¨èçš„æœ€ä½³å®è·µ**ï¼ˆåŸºäºå®é™…æ¡†æ¶è¡Œä¸ºï¼‰ï¼š

```rust
/// ä¼˜åŒ–çš„æ’ä»¶å®ç° - å……åˆ†åˆ©ç”¨ transactions å‚æ•°
#[async_trait]
impl PluginTrait for ValidationPlugin {
    async fn append_transaction(
        &self,
        transactions: &[Transaction],  // ğŸ‘ˆ ç›´æ¥ä½¿ç”¨è¿™ä¸ªå‚æ•°
        old_state: &State,
        new_state: &State,
    ) -> StateResult<Option<Transaction>> {
        // ğŸ”„ ç­–ç•¥1: ç›´æ¥ä» transactions ä¸­è·å–æ•°æ®ï¼ˆæ¨èï¼‰
        for transaction in transactions {
            if transaction.has_meta("price_calculation_completed") {
                // ç›´æ¥ä»äº‹åŠ¡ meta è·å–æ•°æ®ï¼Œæ— éœ€çŠ¶æ€æŸ¥æ‰¾
                if let Some(results) = transaction.get_meta::<Vec<CalculationResult>>("calculation_results") {
                    return self.process_calculation_results(results).await;
                }
            }
        }
        
        // ğŸ”„ ç­–ç•¥2: ä»çŠ¶æ€è·å–æŒä¹…åŒ–æ•°æ®ï¼ˆä»…åœ¨å¿…è¦æ—¶ï¼‰
        // åªæœ‰å½“éœ€è¦è®¿é—®å†å²æ•°æ®ã€ç¼“å­˜æˆ–è·¨äº‹åŠ¡çŠ¶æ€æ—¶æ‰ä½¿ç”¨
        if let Some(plugin_state) = new_state.get_field("validation") {
            // è®¿é—®æŒä¹…åŒ–çš„æ’ä»¶çŠ¶æ€
        }
        
        Ok(None)
    }
}

impl ValidationPlugin {
    async fn process_calculation_results(
        &self, 
        results: Vec<CalculationResult>
    ) -> StateResult<Option<Transaction>> {
        let mut notification_transaction = Transaction::new();
        
        // éªŒè¯é€»è¾‘...
        let validation_results = self.validate_results(&results).await;
        
        // åªä¼ é€’å¿…è¦çš„æ•°æ®åˆ°ä¸‹æ¸¸
        notification_transaction.set_meta("validation_completed", true);
        notification_transaction.set_meta("validation_results", validation_results);
        
        Ok(Some(notification_transaction))
    }
}
```

**ä½•æ—¶ä½¿ç”¨å“ªç§æ–¹å¼**ï¼š

| ä½¿ç”¨åœºæ™¯ | Transaction Meta | State å­˜å‚¨ |
|---------|------------------|------------|
| æ’ä»¶é—´æ•°æ®ä¼ é€’ | âœ… é¦–é€‰ | âŒ è¿‡åº¦è®¾è®¡ |
| ä¸´æ—¶è®¡ç®—ç»“æœ | âœ… åˆé€‚ | âŒ ä¸å¿…è¦ |
| ç¼“å­˜å’Œæ€§èƒ½ä¼˜åŒ– | âŒ ä¸åˆé€‚ | âœ… å¿…è¦ |
| å†å²è®°å½•å’Œç»Ÿè®¡ | âŒ ä¸åˆé€‚ | âœ… å¿…è¦ |
| è·¨äº‹åŠ¡çŠ¶æ€ | âŒ ä¸å¯èƒ½ | âœ… å¿…è¦ |
| å¤§å‹å¤æ‚å¯¹è±¡ | âš ï¸ è°¨æ…ä½¿ç”¨ | âœ… æ¨è |

#### ä½¿ç”¨æ’ä»¶ä¾èµ–çš„å®Œæ•´ç¤ºä¾‹

```rust
async fn example_dependent_plugins_workflow() -> Result<()> {
    // 1. åˆ›å»ºç¼–è¾‘å™¨é…ç½®
    let create_callback = Arc::new(SimpleNodePoolFn);
    let mut builder = EditorOptionsBuilder::new();
    builder = builder
        .content(Content::NodePoolFn(create_callback))
        .extensions(init_dependent_extensions()); // ä½¿ç”¨ä¾èµ–æ’ä»¶é…ç½®
    
    let options = builder.build();
    let mut editor = DemoEditor::create(DemoEditorOptions {
        editor_options: options
    }).await?;
    
    // 2. åˆ›å»ºéœ€è¦è®¡ç®—çš„èŠ‚ç‚¹
    let mut transaction = Transaction::new();
    
    let calc_node = Node::new(
        "item_001".to_string(),
        NodeType::text("calculation_item"),
        Attrs::from([
            ("base_price".to_string(), 100.0.into()),
            ("quantity".to_string(), 5.0.into()),
            ("rate".to_string(), 1.2.into()),
        ]),
        None,
    );
    
    transaction.add_step(AddNodeStep::new_single(calc_node, None));
    
    // 3. è®¾ç½®è§¦å‘æ’ä»¶é“¾çš„ meta ä¿¡æ¯
    transaction.set_meta("nodes_to_calculate", vec!["item_001".to_string()]);
    transaction.set_meta("trigger_validation", true);
    transaction.set_meta("generate_summary", true);
    
    // 4. æ‰§è¡Œäº‹åŠ¡ï¼Œè§¦å‘æ’ä»¶é“¾
    editor.dispatch_flow_with_meta(
        transaction,
        "æ‰§è¡Œä»·æ ¼è®¡ç®—å’ŒéªŒè¯".to_string(),
        serde_json::json!({
            "workflow": "price_calculation_validation",
            "initiator": "user"
        })
    ).await?;
    
    // 5. è·å–æœ€ç»ˆç»“æœ
    let state = editor.get_state().await;
    let resource_manager = state.resource_manager();
    
    // è·å–æ±‡æ€»æŠ¥å‘Š
    if let Some(summary) = resource_manager.resource_table
        .get::<SummaryReport>("summary_report".to_string()) 
    {
        println!("æ±‡æ€»æŠ¥å‘Š: {:?}", summary);
    }
    
    Ok(())
}
```

#### æœ€ä½³å®è·µ

åŸºäºçœŸå®æ¡†æ¶çš„æ’ä»¶ä¾èµ–ç®¡ç†è¦ç‚¹ï¼š

1. **ä¼˜å…ˆä½¿ç”¨ Transaction Meta è¿›è¡Œæ’ä»¶é—´é€šä¿¡**ï¼š
   ```rust
   // âœ… æ¨èï¼šç›´æ¥ä» transactions å‚æ•°è·å–æ•°æ®
   async fn append_transaction(
       &self,
       transactions: &[Transaction],
       old_state: &State,
       new_state: &State,
   ) -> StateResult<Option<Transaction>> {
       // éå†æ‰€æœ‰äº‹åŠ¡ï¼ŒæŸ¥æ‰¾ç›¸å…³çš„ meta æ•°æ®
       for tx in transactions {
           if let Some(data) = tx.get_meta::<Vec<ResultData>>("calculation_results") {
               // âœ… æ­£ç¡®ï¼šä½¿ç”¨ new_state åˆ›å»ºæ–°äº‹åŠ¡
               let mut notification_tx = new_state.tr();
               notification_tx.set_meta("data_processed", true);
               notification_tx.set_meta("processed_data", processed_data);
               return Ok(Some(notification_tx));
           }
       }
       Ok(None)
   }
   
   // âŒ é”™è¯¯ï¼šTransaction::new() éœ€è¦ State å‚æ•°
   // let mut tx = Transaction::new(); // è¿™æ ·ä¼šç¼–è¯‘é”™è¯¯
   
   // âœ… æ­£ç¡®ï¼šä½¿ç”¨ State.tr() æ–¹æ³•åˆ›å»ºäº‹åŠ¡
   // let mut tx = new_state.tr();
   ```

2. **åŒé‡å®ç°æ¨¡å¼çš„è®¾è®¡ç›®çš„**ï¼š
   - `StateField`: ä¸ºæ¯ä¸ªæ’ä»¶å®šä¹‰å•ç‹¬çš„çŠ¶æ€å­˜å‚¨ç©ºé—´ï¼Œç®¡ç†æ’ä»¶ç§æœ‰æ•°æ®
   - `PluginTrait`: æ’ä»¶çš„ä¸šåŠ¡é€»è¾‘å±‚ï¼Œæ ¹æ®ä¸šåŠ¡éœ€æ±‚äº§ç”Ÿæ–°çš„äº‹åŠ¡
   
3. **èŒè´£åˆ†ç¦»åŸåˆ™**ï¼š
   ```rust
   // StateField: çº¯ç²¹çš„çŠ¶æ€ç®¡ç†ï¼Œä¸äº§ç”Ÿæ–°äº‹åŠ¡
   impl StateField {
       async fn apply() -> Arc<dyn Resource> {
           // âœ… åªè´Ÿè´£ï¼šæ›´æ–°æ’ä»¶çŠ¶æ€ã€ç¼“å­˜æ•°æ®ã€ç»Ÿè®¡ä¿¡æ¯
           // âŒ ä¸è´Ÿè´£ï¼šä¸šåŠ¡é€»è¾‘åˆ¤æ–­ã€äº§ç”Ÿæ–°äº‹åŠ¡
           let updated_state = process_data(transaction_data);
           Arc::new(updated_state)
       }
   }
   
   // PluginTrait: ä¸šåŠ¡é€»è¾‘åˆ¤æ–­ï¼Œå†³å®šæ˜¯å¦äº§ç”Ÿæ–°äº‹åŠ¡
   impl PluginTrait {
       async fn append_transaction(
           &self,
           transactions: &[Transaction],  // ğŸ‘ˆ å……åˆ†åˆ©ç”¨è¿™ä¸ªå‚æ•°
           old_state: &State,
           new_state: &State,
       ) -> StateResult<Option<Transaction>> {
           // âœ… åªè´Ÿè´£ï¼šä¸šåŠ¡é€»è¾‘åˆ¤æ–­ã€æ¡ä»¶æ£€æŸ¥ã€äº§ç”Ÿæ–°äº‹åŠ¡
           // âŒ ä¸è´Ÿè´£ï¼šçŠ¶æ€å­˜å‚¨ã€æ•°æ®ç¼“å­˜
           
           // ä¼˜å…ˆä» transactions è·å–æ•°æ®
           for tx in transactions {
               if tx.has_meta("trigger_condition") {
                   return Ok(Some(create_notification_transaction()));
               }
           }
           
           // åªæœ‰åœ¨éœ€è¦æŒä¹…åŒ–çŠ¶æ€æ—¶æ‰è®¿é—® State
           Ok(None)
       }
   }
   ```

3. **æ’ä»¶ç‹¬ç«‹çŠ¶æ€ç©ºé—´**ï¼š
   - æ¯ä¸ªæ’ä»¶æ‹¥æœ‰å®Œå…¨ç‹¬ç«‹çš„çŠ¶æ€ç»“æ„ä½“
   - çŠ¶æ€åŒ…å«ï¼šè®¡ç®—ç»“æœã€ç¼“å­˜æ•°æ®ã€ç»Ÿè®¡ä¿¡æ¯ã€é…ç½®å‚æ•°
   - é€šè¿‡ `StateField` ç®¡ç†ï¼Œé€šè¿‡ `PluginTrait` ä½¿ç”¨

4. **Transaction åˆ›å»ºçš„æ­£ç¡®æ–¹å¼**ï¼š
   ```rust
   // âœ… æ­£ç¡®ï¼šå¿…é¡»ä½¿ç”¨ State æ¥åˆ›å»º Transaction
   async fn append_transaction(
       &self,
       transactions: &[Transaction],
       old_state: &State,
       new_state: &State,
   ) -> StateResult<Option<Transaction>> {
       // ä½¿ç”¨ new_state åˆ›å»ºæ–°äº‹åŠ¡
       let mut new_transaction = new_state.tr();
       new_transaction.set_meta("plugin_completed", true);
       Ok(Some(new_transaction))
   }
   
   // âŒ é”™è¯¯ï¼šè¿™æ ·ä¼šç¼–è¯‘å¤±è´¥
   // let mut tx = Transaction::new(); // ç¼ºå°‘ State å‚æ•°
   
   // ğŸ“š åŸå› ï¼šTransaction::new(state: &State) éœ€è¦ State å‚æ•°
   // è¿™æ˜¯å› ä¸º Transaction éœ€è¦è®¿é—®æ–‡æ¡£çŠ¶æ€å’Œé…ç½®ä¿¡æ¯
   ```

5. **Meta æ•°æ®è®¾è®¡**ï¼š
   - ä½¿ç”¨è¯­ä¹‰åŒ–çš„é”®åï¼š`price_calculation_completed`ã€`validation_failures`
   - ä¼ é€’è½»é‡çº§æ ‡è¯†ï¼Œå¤æ‚æ•°æ®å­˜å‚¨åœ¨æ’ä»¶çŠ¶æ€ä¸­
   - é¿å…åœ¨ meta ä¸­å­˜å‚¨å¤§é‡æ•°æ®

6. **ä¼˜å…ˆçº§è®¾ç½®**ï¼š
   ```rust
   priority: 10,  // A æ’ä»¶å…ˆæ‰§è¡Œ
   priority: 20,  // B æ’ä»¶åæ‰§è¡Œï¼ˆä¾èµ– Aï¼‰
   priority: 30,  // C æ’ä»¶æœ€åæ‰§è¡Œï¼ˆä¾èµ– Aã€Bï¼‰
   ```

7. **é”™è¯¯å¤„ç†ç­–ç•¥**ï¼š
   - `append_transaction` è¿”å› `StateResult<Option<Transaction>>`
   - è¿”å› `Ok(None)` è¡¨ç¤ºä¸éœ€è¦é¢å¤–äº‹åŠ¡
   - è¿”å› `Err()` ä¸­æ–­æ•´ä¸ªäº‹åŠ¡æµç¨‹

8. **è°ƒè¯•å’Œç›‘æ§**ï¼š
   ```rust
   println!("æ’ä»¶ {} æ”¶åˆ°äº‹åŠ¡: {:?}", plugin_name, tr.meta);
   tracing::debug!("å¤„ç†å®Œæˆï¼Œæäº¤é€šçŸ¥äº‹åŠ¡");
   ```

9. **é¿å…å¾ªç¯ä¾èµ–**ï¼š
   - æ˜ç¡®å®šä¹‰æ’ä»¶é—´çš„ä¾èµ–æ–¹å‘
   - ä½¿ç”¨ä¼˜å…ˆçº§ç¡®ä¿å•å‘æ•°æ®æµ
   - é¿å…æ’ä»¶ A ä¾èµ–æ’ä»¶ Bï¼ŒåŒæ—¶æ’ä»¶ B åˆä¾èµ–æ’ä»¶ A

10. **èµ„æºæ¸…ç†**ï¼š
    - å®šæœŸæ¸…ç†è¿‡æœŸçš„è®¡ç®—ç»“æœ
    - åœ¨æ’ä»¶çŠ¶æ€ä¸­ç®¡ç†æ•°æ®ç”Ÿå‘½å‘¨æœŸ
    - é¿å…åœ¨èµ„æºè¡¨ä¸­ç§¯ç´¯è¿‡å¤šä¸´æ—¶æ•°æ®

11. **Transaction Meta ä¼˜å…ˆåŸåˆ™**ï¼š
    ```rust
    /// æ’ä»¶é—´æ•°æ®æµè½¬çš„æœ€ä½³å®è·µ
    /// 
    /// âœ… æ¨èæ–¹å¼ï¼šä½¿ç”¨ Transaction Meta
    /// append_transaction(transactions: &[Transaction], ...) {
    ///     for tx in transactions {
    ///         if let Some(data) = tx.get_meta("calculation_results") {
    ///             // ç›´æ¥å¤„ç†æ•°æ®ï¼Œé«˜æ•ˆä¸”ç®€æ´
    ///             let mut new_tx = new_state.tr(); // âœ… æ­£ç¡®åˆ›å»ºæ–¹å¼
    ///             new_tx.set_meta("processed", true);
    ///             return Ok(Some(new_tx));
    ///         }
    ///     }
    /// }
    /// 
    /// âŒ é¿å…æ–¹å¼ï¼šä¸å¿…è¦çš„çŠ¶æ€å­˜å‚¨
    /// // åªæœ‰åœ¨éœ€è¦è·¨äº‹åŠ¡æŒä¹…åŒ–æ—¶æ‰ä½¿ç”¨ State å­˜å‚¨
    /// if let Some(plugin_state) = new_state.get_field("plugin_name") {
    ///     // ä»…ç”¨äºç¼“å­˜ã€ç»Ÿè®¡ã€å†å²è®°å½•ç­‰åœºæ™¯
    /// }
    ```

12. **æ–‡æ¡£åŒ–ä¾èµ–å…³ç³»**ï¼š
    ```rust
    /// æ’ä»¶ä¾èµ–å›¾ï¼š
    /// åŸå§‹äº‹åŠ¡ â†’ æ’ä»¶A(è®¡ç®—) â†’ é€šçŸ¥äº‹åŠ¡â‚ â†’ æ’ä»¶B(éªŒè¯) â†’ é€šçŸ¥äº‹åŠ¡â‚‚ â†’ æ’ä»¶C(æ±‡æ€»)
    /// 
    /// Meta æµè½¬ï¼ˆæ¨èï¼‰ï¼š
    /// - "nodes_to_calculate" â†’ è§¦å‘æ’ä»¶A
    /// - "price_calculation_completed" â†’ è§¦å‘æ’ä»¶B  
    /// - "validation_completed" â†’ è§¦å‘æ’ä»¶C
    /// 
    /// æ•°æ®è®¿é—®æ–¹å¼ï¼š
    /// - ä¸´æ—¶æ•°æ®ï¼štransactions[].get_meta() ï¼ˆæ¨èï¼‰
    /// - æŒä¹…åŒ–æ•°æ®ï¼šstate.get_field() ï¼ˆä»…åœ¨å¿…è¦æ—¶ï¼‰
    /// 
    /// Transaction åˆ›å»ºï¼š
    /// - å¿…é¡»ä½¿ç”¨ï¼šnew_state.tr() ï¼ˆæ­£ç¡®ï¼‰
    /// - é¿å…ä½¿ç”¨ï¼šTransaction::new() ï¼ˆé”™è¯¯ï¼‰
    ```

### 5. ç¼–è¾‘å™¨åˆ›å»ºå’Œé…ç½®

```rust
use std::sync::Arc;
use mf_core::{
    extension::Extension,
    types::{Content, EditorOptionsBuilder, Extensions, NodePoolFnTrait},
    runtime::async_runtime::ForgeAsyncRuntime,
};
use mf_state::plugin::{Plugin, PluginSpec};
use anyhow::Result;

pub struct DemoEditorOptions {
    pub editor_options: RuntimeOptions,
}

pub struct DemoEditor {
    editor: ForgeAsyncRuntime,
    options: DemoEditorOptions,
}

impl DemoEditor {
    pub async fn create(options: DemoEditorOptions) -> Result<Self> {
        let editor = ForgeAsyncRuntime::create(options.editor_options.clone()).await?;
        Ok(Self { editor, options })
    }
}

/// è·å–ç¼–è¾‘å™¨é…ç½®
pub async fn init_options(
    create_callback: Arc<dyn NodePoolFnTrait>
) -> DemoEditorOptions {
    let mut builder = EditorOptionsBuilder::new();
    builder = builder
        .content(Content::NodePoolFn(create_callback))
        // è®¾ç½®å†å²è®°å½•é™åˆ¶
        .history_limit(20)
        // æ·»åŠ æ‰©å±•
        .extensions(init_extension())
        // æ·»åŠ ä¸­é—´ä»¶
        .add_middleware(CollectFbfxCsxmMiddleware);
        
    let options = builder.build();
    DemoEditorOptions { editor_options: options }
}

/// è·å–æ‰©å±•é…ç½®
pub fn init_extension() -> Vec<Extensions> {
    let mut extensions = vec![
        // æ·»åŠ æ ‡è®°æ‰©å±•
        Extensions::M(BG_COLOR.clone()),
        Extensions::M(FOOTNOTE.clone()),
    ];
    
    // æ·»åŠ èŠ‚ç‚¹æ‰©å±•
    let nodes = init_nodes();
    for mut node in nodes {
        // å¯ä»¥åœ¨è¿™é‡Œè®¾ç½®èŠ‚ç‚¹çš„å†…å®¹æ¨¡å¼
        if node.get_name() == "djgc" {
            node.set_content("djgcRowNode+");
        }
        extensions.push(Extensions::N(node));
    }
    
    // æ·»åŠ æ’ä»¶æ‰©å±•
    let mut extension = Extension::new();
    let inc_plugin = Plugin::new(PluginSpec {
        key: ("inc_plugin".to_string(), "å¢é‡æ•°æ®æ’ä»¶".to_string()),
        state_field: Some(Arc::new(IncStateField)),
        tr: None,
        priority: 10,
    });
    extension.add_plugin(Arc::new(inc_plugin));
    extensions.push(Extensions::E(extension));
    
    extensions
}

/// åˆ›å»ºç¼–è¾‘å™¨
pub async fn init_editor(options: DemoEditorOptions) -> DemoEditor {
    DemoEditor::create(options).await.unwrap()
}
```

### 6. çŠ¶æ€ç®¡ç†å’Œäº‹åŠ¡

```rust
use mf_state::{Transaction, State, transaction::Command};
use mf_transform::{AddNodeStep, AttrStep};
use mf_model::{Node, Attrs};
use std::sync::Arc;

// å®ç°å‘½ä»¤æ¨¡å¼è¿›è¡ŒçŠ¶æ€æ›´æ–°
async fn update_node_example(editor: &mut DemoEditor, node_id: String, new_attrs: Attrs) -> Result<()> {
    // åˆ›å»ºäº‹åŠ¡
    let mut transaction = Transaction::new();
    transaction.add_step(AttrStep::new(node_id, new_attrs));
    transaction.set_meta("action", "update_node_attrs");
    
    // åº”ç”¨äº‹åŠ¡
    editor.dispatch_flow_with_meta(
        transaction,
        "æ›´æ–°èŠ‚ç‚¹å±æ€§".to_string(),
        serde_json::json!({"type": "attr_update"})
    ).await?;
    
    Ok(())
}

// æ·»åŠ èŠ‚ç‚¹
async fn add_node_example(editor: &mut DemoEditor, parent_id: Option<String>) -> Result<()> {
    // åˆ›å»ºæ–°èŠ‚ç‚¹
    let node = DJGC_NODE.clone();
    
    // åˆ›å»ºäº‹åŠ¡
    let mut transaction = Transaction::new();
    transaction.add_step(AddNodeStep::new_single(node, parent_id));
    transaction.set_meta("action", "add_node");
    
    // åº”ç”¨äº‹åŠ¡
    editor.dispatch_flow_with_meta(
        transaction,
        "æ·»åŠ èŠ‚ç‚¹".to_string(),
        serde_json::json!({"type": "node_add"})
    ).await?;
    
    Ok(())
}
```

### 7. Tauri é›†æˆ (æ¡Œé¢åº”ç”¨å¼€å‘)

#### å‰ç«¯ JavaScript/TypeScript

```typescript
// src/api/editor.ts
import { invoke, listen } from '@tauri-apps/api/tauri';

export interface NodeData {
  id: string;
  type: string;
  attrs: Record<string, any>;
  content?: string;
}

export class EditorAPI {
  // è°ƒç”¨åç«¯å‘½ä»¤
  static async createNode(parentId: string | null, nodeData: NodeData): Promise<void> {
    await invoke('create_node', { parentId, nodeData });
  }

  static async updateNodeAttrs(nodeId: string, attrs: Record<string, any>): Promise<void> {
    await invoke('update_node_attrs', { nodeId, attrs });
  }

  static async deleteNode(nodeId: string): Promise<void> {
    await invoke('delete_node', { nodeId });
  }

  static async getDocumentState(): Promise<any> {
    return await invoke('get_document_state');
  }

  // ç›‘å¬åç«¯äº‹ä»¶
  static async listenToStateChanges(callback: (state: any) => void): Promise<void> {
    await listen('state-changed', (event) => {
      callback(event.payload);
    });
  }

  static async listenToErrors(callback: (error: string) => void): Promise<void> {
    await listen('editor-error', (event) => {
      callback(event.payload as string);
    });
  }
}

// ä½¿ç”¨ç¤ºä¾‹
async function setupEditor() {
  // ç›‘å¬çŠ¶æ€å˜åŒ–
  await EditorAPI.listenToStateChanges((newState) => {
    console.log('çŠ¶æ€å·²æ›´æ–°:', newState);
    // æ›´æ–° UI
  });

  // ç›‘å¬é”™è¯¯
  await EditorAPI.listenToErrors((error) => {
    console.error('ç¼–è¾‘å™¨é”™è¯¯:', error);
  });

  // åˆ›å»ºèŠ‚ç‚¹
  await EditorAPI.createNode(null, {
    id: 'root',
    type: 'document',
    attrs: { title: 'æ–°æ–‡æ¡£' }
  });
}
```

#### åç«¯ Rust Commands

```rust
// src/commands/editor.rs
use tauri::{command, State, Window};
use serde::{Deserialize, Serialize};
use std::sync::Mutex;
use crate::editor::{DemoEditor, EditorAPI};

#[derive(Debug, Deserialize)]
pub struct NodeData {
    id: String,
    #[serde(rename = "type")]
    node_type: String,
    attrs: serde_json::Value,
    content: Option<String>,
}

// å…¨å±€ç¼–è¾‘å™¨çŠ¶æ€
pub type EditorState = Mutex<Option<DemoEditor>>;

#[command]
pub async fn create_node(
    parent_id: Option<String>,
    node_data: NodeData,
    editor_state: State<'_, EditorState>,
    window: Window,
) -> Result<(), String> {
    let mut editor_guard = editor_state.lock().map_err(|e| e.to_string())?;
    let editor = editor_guard.as_mut().ok_or("ç¼–è¾‘å™¨æœªåˆå§‹åŒ–")?;

    // åˆ›å»ºèŠ‚ç‚¹
    match EditorAPI::create_node(editor, parent_id, node_data).await {
        Ok(_) => {
            // å‘é€çŠ¶æ€æ›´æ–°äº‹ä»¶åˆ°å‰ç«¯
            let new_state = editor.get_state().await;
            window.emit("state-changed", &*new_state).map_err(|e| e.to_string())?;
            Ok(())
        }
        Err(e) => {
            // å‘é€é”™è¯¯äº‹ä»¶åˆ°å‰ç«¯
            window.emit("editor-error", e.to_string()).map_err(|e| e.to_string())?;
            Err(e.to_string())
        }
    }
}

#[command]
pub async fn update_node_attrs(
    node_id: String,
    attrs: serde_json::Value,
    editor_state: State<'_, EditorState>,
    window: Window,
) -> Result<(), String> {
    let mut editor_guard = editor_state.lock().map_err(|e| e.to_string())?;
    let editor = editor_guard.as_mut().ok_or("ç¼–è¾‘å™¨æœªåˆå§‹åŒ–")?;

    match EditorAPI::update_node_attrs(editor, node_id, attrs).await {
        Ok(_) => {
            let new_state = editor.get_state().await;
            window.emit("state-changed", &*new_state).map_err(|e| e.to_string())?;
            Ok(())
        }
        Err(e) => {
            window.emit("editor-error", e.to_string()).map_err(|e| e.to_string())?;
            Err(e.to_string())
        }
    }
}

#[command]
pub async fn delete_node(
    node_id: String,
    editor_state: State<'_, EditorState>,
    window: Window,
) -> Result<(), String> {
    let mut editor_guard = editor_state.lock().map_err(|e| e.to_string())?;
    let editor = editor_guard.as_mut().ok_or("ç¼–è¾‘å™¨æœªåˆå§‹åŒ–")?;

    match EditorAPI::delete_node(editor, node_id).await {
        Ok(_) => {
            let new_state = editor.get_state().await;
            window.emit("state-changed", &*new_state).map_err(|e| e.to_string())?;
            Ok(())
        }
        Err(e) => {
            window.emit("editor-error", e.to_string()).map_err(|e| e.to_string())?;
            Err(e.to_string())
        }
    }
}

#[command]
pub async fn get_document_state(
    editor_state: State<'_, EditorState>,
) -> Result<serde_json::Value, String> {
    let editor_guard = editor_state.lock().map_err(|e| e.to_string())?;
    let editor = editor_guard.as_ref().ok_or("ç¼–è¾‘å™¨æœªåˆå§‹åŒ–")?;

    let state = editor.get_state().await;
    // åºåˆ—åŒ–çŠ¶æ€ä¸º JSON
    serde_json::to_value(&*state).map_err(|e| e.to_string())
}

#[command]
pub async fn initialize_editor(
    editor_state: State<'_, EditorState>,
    window: Window,
) -> Result<(), String> {
    // åˆ›å»ºç¼–è¾‘å™¨å®ä¾‹
    let create_callback = Arc::new(SimpleNodePoolFn);
    let options = init_options(create_callback).await;
    let editor = init_editor(options).await;

    // å­˜å‚¨åˆ°å…¨å±€çŠ¶æ€
    let mut editor_guard = editor_state.lock().map_err(|e| e.to_string())?;
    *editor_guard = Some(editor);

    // å‘é€åˆå§‹åŒ–å®Œæˆäº‹ä»¶
    window.emit("editor-initialized", ()).map_err(|e| e.to_string())?;
    
    Ok(())
}
```

#### main.rs é…ç½®

```rust
// src/main.rs
use tauri::Manager;
use std::sync::Mutex;

mod commands;
mod editor;
mod nodes;
mod marks;
mod middleware;
mod plugins;

use commands::editor::*;

fn main() {
    tauri::Builder::default()
        .manage(EditorState(Mutex::new(None)))
        .invoke_handler(tauri::generate_handler![
            initialize_editor,
            create_node,
            update_node_attrs,
            delete_node,
            get_document_state,
        ])
        .setup(|app| {
            // åº”ç”¨å¯åŠ¨æ—¶çš„åˆå§‹åŒ–é€»è¾‘
            let window = app.get_window("main").unwrap();
            
            // å¯ä»¥åœ¨è¿™é‡Œè¿›è¡Œä¸€äº›åˆå§‹åŒ–å·¥ä½œ
            tracing_subscriber::fmt::init();
            
            Ok(())
        })
        .run(tauri::generate_context!())
        .expect("å¯åŠ¨ Tauri åº”ç”¨å¤±è´¥");
}
```

#### Tauri é…ç½® (tauri.conf.json)

```json
{
  "build": {
    "beforeBuildCommand": "npm run build",
    "beforeDevCommand": "npm run dev",
    "devPath": "http://localhost:3000",
    "distDir": "../dist"
  },
  "package": {
    "productName": "ModuForge App",
    "version": "0.1.0"
  },
  "tauri": {
    "allowlist": {
      "all": false,
      "shell": {
        "all": false,
        "open": true
      },
      "window": {
        "all": false,
        "close": true,
        "hide": true,
        "show": true,
        "maximize": true,
        "minimize": true,
        "unmaximize": true,
        "unminimize": true,
        "startDragging": true
      }
    },
    "bundle": {
      "active": true,
      "category": "DeveloperTool",
      "copyright": "",
      "deb": {
        "depends": []
      },
      "externalBin": [],
      "icon": [
        "icons/32x32.png",
        "icons/128x128.png",
        "icons/128x128@2x.png",
        "icons/icon.icns",
        "icons/icon.ico"
      ],
      "identifier": "com.moduforge.app",
      "longDescription": "",
      "macOS": {
        "entitlements": null,
        "exceptionDomain": "",
        "frameworks": [],
        "providerShortName": null,
        "signingIdentity": null
      },
      "resources": [],
      "shortDescription": "",
      "targets": "all",
      "windows": {
        "certificateThumbprint": null,
        "digestAlgorithm": "sha256",
        "timestampUrl": ""
      }
    },
    "security": {
      "csp": null
    },
    "updater": {
      "active": false
    },
    "windows": [
      {
        "fullscreen": false,
        "height": 600,
        "resizable": true,
        "title": "ModuForge App",
        "width": 800
      }
    ]
  }
}
```

### 8. è§„åˆ™å¼•æ“ä½¿ç”¨

```rust
use mf_engine::{Engine, loader::MemoryLoader};
use mf_expression::Variable;
use serde_json::json;

async fn rules_example() -> Result<()> {
    // åˆ›å»ºè§„åˆ™å¼•æ“
    let loader = MemoryLoader::default();
    let engine = Engine::new(loader);
    
    // å‡†å¤‡è¾“å…¥æ•°æ®
    let input = Variable::from(json!({
        "user": {
            "age": 25,
            "membership": "premium"
        }
    }));
    
    // æ‰§è¡Œè§„åˆ™
    let result = engine.evaluate("user_rules", &input).await?;
    println!("è§„åˆ™æ‰§è¡Œç»“æœ: {:?}", result);
    
    Ok(())
}
```

### 9. è¡¨è¾¾å¼è¯­è¨€

```rust
use mf_expression::{Expression, Variable};
use serde_json::json;

fn expression_example() -> Result<()> {
    // ç¼–è¯‘è¡¨è¾¾å¼
    let expr = Expression::compile("user.age >= 18 && user.status == 'active'")?;
    
    // å‡†å¤‡æ•°æ®
    let data = Variable::from(json!({
        "user": {
            "age": 25,
            "status": "active"
        }
    }));
    
    // æ‰§è¡Œè¡¨è¾¾å¼
    let result = expr.execute(&data)?;
    println!("è¡¨è¾¾å¼ç»“æœ: {:?}", result.to_bool());
    
    Ok(())
}
```

### 10. åä½œåŠŸèƒ½

```rust
use mf_collaboration::{SyncService, types::RoomConfig};
use tokio_tungstenite::tungstenite::protocol::Message;

async fn collaboration_example() -> Result<()> {
    // åˆ›å»ºåä½œæœåŠ¡
    let mut sync_service = SyncService::new();
    
    // åˆ›å»ºæˆ¿é—´
    let room_config = RoomConfig {
        room_id: "doc_123".to_string(),
        max_clients: 10,
    };
    
    sync_service.create_room(room_config).await?;
    
    // å¤„ç†å®¢æˆ·ç«¯æ¶ˆæ¯
    // let message = Message::text("sync_data");
    // sync_service.handle_message("doc_123", "client_1", message).await?;
    
    Ok(())
}
```

### 11. æ–‡ä»¶æ“ä½œ

```rust
use mf_file::{ZipDocWriter, formats::JsonFormat};
use std::path::Path;

async fn file_export_example(state: &State) -> Result<()> {
    // åˆ›å»º ZIP æ–‡æ¡£å†™å…¥å™¨
    let mut writer = ZipDocWriter::new();
    
    // è®¾ç½®æ ¼å¼
    writer.set_format(Box::new(JsonFormat::new()));
    
    // å¯¼å‡ºæ–‡æ¡£
    let output_path = Path::new("output.zip");
    writer.export_document(state, output_path).await?;
    
    println!("æ–‡æ¡£å·²å¯¼å‡ºåˆ°: {:?}", output_path);
    Ok(())
}
```

### 12. æœç´¢åŠŸèƒ½

```rust
use mf_search::{SearchService, model::{IndexRequest, SearchRequest}};

async fn search_example() -> Result<()> {
    // åˆ›å»ºæœç´¢æœåŠ¡
    let mut search_service = SearchService::new();
    
    // åˆ›å»ºç´¢å¼•
    let index_req = IndexRequest {
        document_id: "doc_1".to_string(),
        content: "è¿™æ˜¯è¦ç´¢å¼•çš„æ–‡æ¡£å†…å®¹".to_string(),
        metadata: Default::default(),
    };
    
    search_service.index_document(index_req).await?;
    
    // æ‰§è¡Œæœç´¢
    let search_req = SearchRequest {
        query: "æ–‡æ¡£å†…å®¹".to_string(),
        limit: 10,
        offset: 0,
    };
    
    let results = search_service.search(search_req).await?;
    println!("æœç´¢ç»“æœ: {:?}", results);
    
    Ok(())
}
```

## å¼€å‘ç¯å¢ƒé…ç½®

### ç³»ç»Ÿè¦æ±‚
- **Rust**: 1.70+ (å»ºè®®ä½¿ç”¨æœ€æ–°ç¨³å®šç‰ˆ)
- **Node.js**: 16+ (ç”¨äº Tauri å‰ç«¯å¼€å‘)
- **æ“ä½œç³»ç»Ÿ**: Windows 10+, macOS 10.15+, Linux (Ubuntu 20.04+)

### å¼€å‘å·¥å…·æ¨è
```bash
# Rust å·¥å…·é“¾
rustup update stable
rustup component add clippy rustfmt rust-analyzer

# å¼€å‘å·¥å…·
cargo install cargo-edit    # ä¾èµ–ç®¡ç†
cargo install cargo-watch   # è‡ªåŠ¨é‡æ–°ç¼–è¯‘
cargo install cargo-audit   # å®‰å…¨å®¡è®¡
cargo install tauri-cli     # Tauri CLI (å¦‚æœä½¿ç”¨æ¡Œé¢åº”ç”¨)

# IDE æ’ä»¶æ¨è
# - VS Code: rust-analyzer, Tauri, Error Lens
# - IntelliJ: Rust Plugin
# - Vim/Neovim: rust.vim, coc-rust-analyzer
```

### ç¯å¢ƒå˜é‡é…ç½®
```bash
# .env æ–‡ä»¶ç¤ºä¾‹
RUST_LOG=debug                           # æ—¥å¿—çº§åˆ«
MODUFORGE_DATA_DIR=./data                # æ•°æ®ç›®å½•
MODUFORGE_CACHE_SIZE=1000               # ç¼“å­˜å¤§å°
MODUFORGE_COLLABORATION_URL=ws://localhost:8080  # åä½œæœåŠ¡å™¨
DATABASE_URL=sqlite:./app.db            # æ•°æ®åº“è¿æ¥
```

## å¸¸ç”¨å¼€å‘å‘½ä»¤

### æ„å»ºå’Œæµ‹è¯•
```bash
# åŸºç¡€æ„å»º
cargo build
cargo build --release

# åŠŸèƒ½ç‰¹å®šæ„å»º
cargo build --features collaboration
cargo build --all-features

# æµ‹è¯•
cargo test                              # æ‰€æœ‰æµ‹è¯•
cargo test --lib                        # å•å…ƒæµ‹è¯•
cargo test --test integration           # é›†æˆæµ‹è¯•
cargo test -p mf-core                   # ç‰¹å®šåŒ…æµ‹è¯•
cargo test collaboration -- --nocapture # å¸¦è¾“å‡ºçš„æµ‹è¯•

# ä»£ç è´¨é‡
cargo fmt                               # æ ¼å¼åŒ–
cargo clippy                            # é™æ€åˆ†æ
cargo clippy --fix                      # è‡ªåŠ¨ä¿®å¤
cargo audit                             # å®‰å…¨å®¡è®¡

# æ–‡æ¡£
cargo doc --open                        # ç”Ÿæˆå¹¶æ‰“å¼€æ–‡æ¡£
cargo doc --document-private-items      # åŒ…å«ç§æœ‰é¡¹çš„æ–‡æ¡£
```

### Tauri å¼€å‘å‘½ä»¤
```bash
# å¼€å‘æ¨¡å¼
cargo tauri dev                         # å¯åŠ¨å¼€å‘æœåŠ¡å™¨
cargo tauri dev -- --features debug    # å¸¦è°ƒè¯•åŠŸèƒ½

# æ„å»º
cargo tauri build                       # æ„å»ºç”Ÿäº§ç‰ˆæœ¬
cargo tauri build --debug              # æ„å»ºè°ƒè¯•ç‰ˆæœ¬

# å›¾æ ‡ç”Ÿæˆ
cargo tauri icon path/to/icon.png      # ç”Ÿæˆåº”ç”¨å›¾æ ‡
```

### ç¤ºä¾‹å’Œæ¼”ç¤º
```bash
# æ ¸å¿ƒåŠŸèƒ½ç¤ºä¾‹
cargo run --example basic_usage
cargo run --example node_operations
cargo run --example state_management

# é›†æˆç¤ºä¾‹
cargo run --example collaboration_demo
cargo run --example rules_engine_demo
cargo run --example file_operations
cargo run --example tauri_integration

# æ€§èƒ½æµ‹è¯•
cargo bench                             # è¿è¡ŒåŸºå‡†æµ‹è¯•
cargo bench --features collaboration    # åä½œåŠŸèƒ½åŸºå‡†æµ‹è¯•
```

## é”™è¯¯å¤„ç†å’Œè°ƒè¯•

### å¸¸è§é”™è¯¯åŠè§£å†³æ–¹æ¡ˆ

#### 1. ç¼–è¯‘é”™è¯¯
```bash
# ä¾èµ–ç‰ˆæœ¬å†²çª
error: failed to select a version for `serde`
# è§£å†³æ–¹æ¡ˆï¼š
cargo update
cargo clean && cargo build

# ç‰¹å¾å†²çª
error: the trait bound is not satisfied
# è§£å†³æ–¹æ¡ˆï¼šæ£€æŸ¥ Cargo.toml ä¸­çš„ features é…ç½®
```

#### 2. è¿è¡Œæ—¶é”™è¯¯
```rust
// çŠ¶æ€åˆå§‹åŒ–å¤±è´¥
Error: "ç¼–è¾‘å™¨æœªåˆå§‹åŒ–"
// è§£å†³æ–¹æ¡ˆï¼šç¡®ä¿åœ¨ä½¿ç”¨å‰è°ƒç”¨åˆå§‹åŒ–
let editor = init_editor(options).await?;

// äº‹åŠ¡å¤±è´¥
Error: "Transaction validation failed"
// è§£å†³æ–¹æ¡ˆï¼šæ£€æŸ¥äº‹åŠ¡æ­¥éª¤çš„æœ‰æ•ˆæ€§å’Œé¡ºåº
```

#### 3. Tauri é›†æˆé”™è¯¯
```typescript
// IPC è°ƒç”¨å¤±è´¥
Error: "Command not found"
// è§£å†³æ–¹æ¡ˆï¼šæ£€æŸ¥å‘½ä»¤æ³¨å†Œå’Œå‚æ•°ç±»å‹åŒ¹é…

// äº‹ä»¶ç›‘å¬å¤±è´¥
Error: "Event listener not working"
// è§£å†³æ–¹æ¡ˆï¼šç¡®ä¿äº‹ä»¶åç§°åŒ¹é…å’Œç›‘å¬å™¨æ­£ç¡®æ³¨å†Œ
```

### è°ƒè¯•æŠ€å·§

#### 1. æ—¥å¿—é…ç½®
```rust
// è¯¦ç»†æ—¥å¿—é…ç½®
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

fn setup_logging() {
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| "moduforge=debug,tauri=info".into()),
        )
        .with(tracing_subscriber::fmt::layer())
        .init();
}

// åœ¨ä»£ç ä¸­ä½¿ç”¨
use tracing::{debug, info, warn, error, instrument};

#[instrument]
async fn process_transaction(transaction: &Transaction) -> Result<()> {
    debug!("å¼€å§‹å¤„ç†äº‹åŠ¡: {}", transaction.id);
    // å¤„ç†é€»è¾‘
    info!("äº‹åŠ¡å¤„ç†å®Œæˆ");
    Ok(())
}
```

#### 2. å¼€å‘æ¨¡å¼è°ƒè¯•
```rust
#[cfg(debug_assertions)]
fn debug_state(state: &State) {
    println!("çŠ¶æ€è°ƒè¯•ä¿¡æ¯:");
    println!("- èŠ‚ç‚¹æ•°é‡: {}", state.node_count());
    println!("- å†…å­˜ä½¿ç”¨: {:?}", state.memory_usage());
}
```

#### 3. æ€§èƒ½ç›‘æ§
```rust
use std::time::Instant;

async fn measured_operation() -> Result<()> {
    let start = Instant::now();
    
    // æ‰§è¡Œæ“ä½œ
    perform_operation().await?;
    
    let duration = start.elapsed();
    if duration.as_millis() > 100 {
        warn!("æ“ä½œè€—æ—¶è¿‡é•¿: {:?}", duration);
    }
    
    Ok(())
}
```

## æµ‹è¯•ç­–ç•¥

### å•å…ƒæµ‹è¯•
```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tokio_test;

    #[tokio::test]
    async fn test_node_creation() {
        let mut editor = create_test_editor().await;
        let node_id = "test_node";
        
        let result = create_node(&mut editor, node_id, test_node_data()).await;
        assert!(result.is_ok());
        
        let state = editor.get_state().await;
        assert!(state.doc().get_node(node_id).is_some());
    }

    #[test]
    fn test_expression_evaluation() {
        let expr = Expression::compile("user.age >= 18").unwrap();
        let data = test_user_data();
        let result = expr.execute(&data).unwrap();
        assert_eq!(result.to_bool(), true);
    }
}
```

### é›†æˆæµ‹è¯•
```rust
// tests/integration_test.rs
use moduforge::*;

#[tokio::test]
async fn test_complete_workflow() {
    // 1. åˆå§‹åŒ–ç¼–è¾‘å™¨
    let mut editor = setup_test_editor().await;
    
    // 2. åˆ›å»ºæ–‡æ¡£ç»“æ„
    create_test_document(&mut editor).await;
    
    // 3. æ‰§è¡Œä¸šåŠ¡æ“ä½œ
    let result = perform_complex_operation(&mut editor).await;
    
    // 4. éªŒè¯ç»“æœ
    assert!(result.is_ok());
    validate_final_state(&editor).await;
}
```

### æ€§èƒ½æµ‹è¯•
```rust
use criterion::{criterion_group, criterion_main, Criterion};

fn bench_node_creation(c: &mut Criterion) {
    let rt = tokio::runtime::Runtime::new().unwrap();
    let editor = rt.block_on(create_test_editor());
    
    c.bench_function("create 1000 nodes", |b| {
        b.to_async(&rt).iter(|| async {
            for i in 0..1000 {
                create_test_node(&editor, &format!("node_{}", i)).await;
            }
        });
    });
}

criterion_group!(benches, bench_node_creation);
criterion_main!(benches);
```

## ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²

### æ„å»ºä¼˜åŒ–
```toml
# Cargo.toml ç”Ÿäº§é…ç½®
[profile.release]
opt-level = 3
lto = true
codegen-units = 1
panic = "abort"
strip = true

# é’ˆå¯¹ç‰¹å®šæ¶æ„ä¼˜åŒ–
[profile.release-with-debug]
inherits = "release"
debug = true
```

### Docker éƒ¨ç½² (åç«¯æœåŠ¡)
```dockerfile
# Dockerfile
FROM rust:1.70 as builder

WORKDIR /app
COPY Cargo.toml Cargo.lock ./
COPY src ./src

# æ„å»ºç”Ÿäº§ç‰ˆæœ¬
RUN cargo build --release

FROM debian:bookworm-slim
RUN apt-get update && apt-get install -y \
    ca-certificates \
    && rm -rf /var/lib/apt/lists/*

COPY --from=builder /app/target/release/your-app /usr/local/bin/your-app

# åˆ›å»ºé root ç”¨æˆ·
RUN useradd -r -s /bin/false appuser
USER appuser

EXPOSE 8080
CMD ["your-app"]
```

### ç³»ç»ŸæœåŠ¡é…ç½® (Linux)
```ini
# /etc/systemd/system/moduforge-app.service
[Unit]
Description=ModuForge Application
After=network.target

[Service]
Type=simple
User=moduforge
Group=moduforge
WorkingDirectory=/opt/moduforge
ExecStart=/opt/moduforge/bin/app
Restart=always
RestartSec=10

# ç¯å¢ƒå˜é‡
Environment=RUST_LOG=info
Environment=DATABASE_URL=sqlite:/opt/moduforge/data/app.db
Environment=MODUFORGE_DATA_DIR=/opt/moduforge/data

# å®‰å…¨è®¾ç½®
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ReadWritePaths=/opt/moduforge/data

[Install]
WantedBy=multi-user.target
```

### ç›‘æ§å’ŒæŒ‡æ ‡

#### 1. åº”ç”¨æŒ‡æ ‡æ”¶é›†
```rust
use metrics::{counter, histogram, gauge};

pub struct AppMetrics;

impl AppMetrics {
    pub fn record_transaction(&self, duration: Duration) {
        histogram!("transaction_duration_seconds", duration);
        counter!("transactions_total", 1);
    }
    
    pub fn record_active_users(&self, count: u64) {
        gauge!("active_users", count as f64);
    }
    
    pub fn record_error(&self, error_type: &str) {
        counter!("errors_total", 1, "type" => error_type.to_string());
    }
}

// é›†æˆåˆ°åº”ç”¨ä¸­
#[instrument]
async fn process_transaction(tx: Transaction) -> Result<()> {
    let start = Instant::now();
    
    match execute_transaction(tx).await {
        Ok(result) => {
            APP_METRICS.record_transaction(start.elapsed());
            Ok(result)
        }
        Err(e) => {
            APP_METRICS.record_error("transaction_failed");
            Err(e)
        }
    }
}
```

#### 2. å¥åº·æ£€æŸ¥ç«¯ç‚¹
```rust
use axum::{response::Json, http::StatusCode};
use serde_json::json;

async fn health_check() -> Result<Json<serde_json::Value>, StatusCode> {
    // æ£€æŸ¥æ•°æ®åº“è¿æ¥
    if !database_healthy().await {
        return Err(StatusCode::SERVICE_UNAVAILABLE);
    }
    
    // æ£€æŸ¥å…³é”®æœåŠ¡
    if !core_services_healthy().await {
        return Err(StatusCode::SERVICE_UNAVAILABLE);
    }
    
    Ok(Json(json!({
        "status": "healthy",
        "timestamp": chrono::Utc::now().to_rfc3339(),
        "version": env!("CARGO_PKG_VERSION")
    })))
}
```

## æ€§èƒ½ä¼˜åŒ–æŒ‡å—

### 1. å†…å­˜ä¼˜åŒ–
```rust
// ä½¿ç”¨å¯¹è±¡æ± å‡å°‘åˆ†é…
use object_pool::Pool;

lazy_static! {
    static ref NODE_POOL: Pool<Node> = Pool::new(100, || Node::default());
}

fn create_optimized_node() -> PooledNode {
    let mut node = NODE_POOL.try_pull().unwrap_or_else(|| Node::default());
    // é‡ç½®èŠ‚ç‚¹çŠ¶æ€
    node.reset();
    node
}

// æ‰¹é‡æ“ä½œä¼˜åŒ–
async fn batch_create_nodes(nodes: Vec<NodeData>) -> Result<()> {
    let mut transaction = Transaction::new();
    
    // æ‰¹é‡æ·»åŠ æ­¥éª¤ï¼Œå‡å°‘äº‹åŠ¡å¼€é”€
    for node_data in nodes {
        transaction.add_step(AddNodeStep::new_single(
            node_data.into(), 
            node_data.parent_id
        ));
    }
    
    // ä¸€æ¬¡æ€§æäº¤
    editor.dispatch_flow(transaction).await
}
```

### 2. å¹¶å‘ä¼˜åŒ–
```rust
use rayon::prelude::*;
use dashmap::DashMap;

// å¹¶è¡ŒèŠ‚ç‚¹å¤„ç†
fn process_nodes_parallel(nodes: Vec<Node>) -> Vec<ProcessedNode> {
    nodes
        .into_par_iter()
        .map(|node| process_single_node(node))
        .collect()
}

// ä½¿ç”¨æ— é”æ•°æ®ç»“æ„
lazy_static! {
    static ref CACHE: DashMap<String, CachedValue> = DashMap::new();
}

fn get_cached_or_compute(key: &str) -> CachedValue {
    CACHE.entry(key.to_string())
        .or_insert_with(|| expensive_computation(key))
        .clone()
}
```

### 3. I/O ä¼˜åŒ–
```rust
// å¼‚æ­¥æ‰¹é‡æ–‡ä»¶æ“ä½œ
async fn batch_save_documents(docs: Vec<Document>) -> Result<()> {
    let futures: Vec<_> = docs
        .into_iter()
        .map(|doc| save_document_async(doc))
        .collect();
    
    // å¹¶å‘æ‰§è¡Œï¼Œä½†é™åˆ¶å¹¶å‘æ•°
    use futures::stream::{iter, StreamExt};
    iter(futures)
        .buffer_unordered(10) // æœ€å¤š10ä¸ªå¹¶å‘
        .try_collect()
        .await
}

// è¿æ¥æ± é…ç½®
#[derive(Clone)]
pub struct DatabaseConfig {
    pub max_connections: u32,
    pub connection_timeout: Duration,
    pub idle_timeout: Duration,
}

impl Default for DatabaseConfig {
    fn default() -> Self {
        Self {
            max_connections: 20,
            connection_timeout: Duration::from_secs(30),
            idle_timeout: Duration::from_secs(600),
        }
    }
}
```

## æ•…éšœæ’é™¤æŒ‡å—

### å¸¸è§é—®é¢˜è¯Šæ–­

#### 1. å†…å­˜æ³„æ¼
```bash
# ä½¿ç”¨ valgrind æ£€æµ‹å†…å­˜é—®é¢˜
valgrind --tool=memcheck --leak-check=full cargo run

# ä½¿ç”¨ heaptrack è¿›è¡Œå †åˆ†æ
heaptrack cargo run
heaptrack_gui heaptrack.your-app.PID.gz
```

#### 2. æ€§èƒ½é—®é¢˜
```bash
# ä½¿ç”¨ perf è¿›è¡Œæ€§èƒ½åˆ†æ
perf record --call-graph=dwarf cargo run
perf report

# ä½¿ç”¨ flamegraph ç”Ÿæˆç«ç„°å›¾
cargo install flamegraph
cargo flamegraph --bin your-app
```

#### 3. æ—¥å¿—åˆ†æ
```bash
# ç»“æ„åŒ–æ—¥å¿—æŸ¥è¯¢
grep "ERROR" app.log | jq '.timestamp, .message'

# æ€§èƒ½ç›¸å…³æ—¥å¿—
grep "duration" app.log | jq '.duration' | sort -n | tail -10
```

### é…ç½®è°ƒä¼˜

#### 1. è¿è¡Œæ—¶å‚æ•°
```bash
# JVM é£æ ¼çš„è¿è¡Œæ—¶è°ƒä¼˜ï¼ˆé’ˆå¯¹å¤§å‹åº”ç”¨ï¼‰
export RUST_MIN_STACK=8388608  # 8MB æ ˆå¤§å°
export RUST_BACKTRACE=1        # å¯ç”¨å›æº¯
export RAYON_NUM_THREADS=8     # é™åˆ¶å¹¶è¡Œçº¿ç¨‹æ•°
```

#### 2. ç³»ç»Ÿçº§ä¼˜åŒ–
```bash
# Linux ç³»ç»Ÿè°ƒä¼˜
echo 'vm.max_map_count=262144' >> /etc/sysctl.conf
echo 'fs.file-max=2097152' >> /etc/sysctl.conf
sysctl -p

# å¢åŠ æ–‡ä»¶æè¿°ç¬¦é™åˆ¶
echo '* soft nofile 65536' >> /etc/security/limits.conf
echo '* hard nofile 65536' >> /etc/security/limits.conf
```

## ç‰ˆæœ¬ç®¡ç†å’Œå‡çº§

### ç‰ˆæœ¬å…¼å®¹æ€§

#### æ”¯æŒçš„ç‰ˆæœ¬èŒƒå›´
```toml
# æ¨èçš„ç‰ˆæœ¬é…ç½®
[dependencies]
# ä½¿ç”¨è¯­ä¹‰åŒ–ç‰ˆæœ¬æ§åˆ¶
moduforge-core = "^0.4.12"    # å…¼å®¹ 0.4.x ç³»åˆ—
moduforge-model = "~0.4.12"   # åªå…è®¸è¡¥ä¸çº§åˆ«æ›´æ–°

# æ£€æŸ¥ç‰ˆæœ¬å…¼å®¹æ€§
[dependencies.moduforge-engine]
version = "0.4.12"
default-features = false
features = ["expression", "decision"]
```

#### å‡çº§æ£€æŸ¥æ¸…å•
```bash
# 1. æ£€æŸ¥å½“å‰ç‰ˆæœ¬
cargo tree | grep moduforge

# 2. æ£€æŸ¥å¯ç”¨æ›´æ–°
cargo outdated

# 3. å®‰å…¨å®¡è®¡
cargo audit

# 4. æµ‹è¯•å…¼å®¹æ€§
cargo test --all-features

# 5. æ£€æŸ¥ç ´åæ€§å˜æ›´
cargo doc --open
```

### æ•°æ®è¿ç§»

#### 1. çŠ¶æ€æ•°æ®è¿ç§»
```rust
use semver::Version;

pub struct DataMigrator {
    from_version: Version,
    to_version: Version,
}

impl DataMigrator {
    pub async fn migrate(&self, data_path: &Path) -> Result<()> {
        match (self.from_version.major, self.to_version.major) {
            (0, 0) => self.migrate_patch().await,
            (0, 1) => self.migrate_major().await,
            _ => Err(anyhow!("ä¸æ”¯æŒçš„ç‰ˆæœ¬è¿ç§»")),
        }
    }

    async fn migrate_patch(&self) -> Result<()> {
        // è¡¥ä¸ç‰ˆæœ¬è¿ç§»ï¼Œé€šå¸¸åªéœ€è¦æ•°æ®æ ¼å¼è°ƒæ•´
        info!("æ‰§è¡Œè¡¥ä¸çº§åˆ«è¿ç§»");
        Ok(())
    }

    async fn migrate_major(&self) -> Result<()> {
        // ä¸»ç‰ˆæœ¬è¿ç§»ï¼Œå¯èƒ½éœ€è¦é‡æ–°æ„å»ºæ•°æ®
        info!("æ‰§è¡Œä¸»ç‰ˆæœ¬è¿ç§»");
        
        // 1. å¤‡ä»½åŸæ•°æ®
        self.backup_data().await?;
        
        // 2. è½¬æ¢æ•°æ®æ ¼å¼
        self.convert_data_format().await?;
        
        // 3. éªŒè¯è¿ç§»ç»“æœ
        self.validate_migration().await?;
        
        Ok(())
    }
}
```

#### 2. é…ç½®æ–‡ä»¶è¿ç§»
```rust
#[derive(Serialize, Deserialize)]
struct ConfigV1 {
    database_url: String,
    cache_size: usize,
}

#[derive(Serialize, Deserialize)]
struct ConfigV2 {
    database: DatabaseConfig,
    cache: CacheConfig,
    // æ–°å¢åŠŸèƒ½é…ç½®
    collaboration: Option<CollaborationConfig>,
}

fn migrate_config(old_config: ConfigV1) -> ConfigV2 {
    ConfigV2 {
        database: DatabaseConfig {
            url: old_config.database_url,
            pool_size: 10, // é»˜è®¤å€¼
        },
        cache: CacheConfig {
            size: old_config.cache_size,
            ttl: Duration::from_secs(300), // æ–°å¢é»˜è®¤å€¼
        },
        collaboration: None, // æ–°åŠŸèƒ½ï¼Œé»˜è®¤å…³é—­
    }
}
```

### æœ€ä½³å®è·µæ€»ç»“

#### 1. é¡¹ç›®ç»„ç»‡
- ä½¿ç”¨å·¥ä½œç©ºé—´ç»„ç»‡å¤šä¸ªç›¸å…³ crate
- éµå¾ª Rust çš„å‘½åçº¦å®šå’Œç›®å½•ç»“æ„
- ç¼–å†™å…¨é¢çš„æ–‡æ¡£å’Œç¤ºä¾‹

#### 2. ä¾èµ–ç®¡ç†
- ä¼˜å…ˆä½¿ç”¨è¯­ä¹‰åŒ–ç‰ˆæœ¬
- å®šæœŸæ›´æ–°ä¾èµ–å¹¶è¿›è¡Œå®‰å…¨å®¡è®¡
- ä½¿ç”¨ç‰¹æ€§é—¨æ§å‡å°‘ç¼–è¯‘æ—¶é—´

#### 3. é”™è¯¯å¤„ç†
- ä½¿ç”¨ `thiserror` å®šä¹‰åº“é”™è¯¯ç±»å‹
- ä½¿ç”¨ `anyhow` å¤„ç†åº”ç”¨çº§é”™è¯¯
- æä¾›æœ‰æ„ä¹‰çš„é”™è¯¯æ¶ˆæ¯å’Œä¸Šä¸‹æ–‡

#### 4. æµ‹è¯•ç­–ç•¥
- ç¼–å†™å•å…ƒæµ‹è¯•è¦†ç›–æ‰€æœ‰å…¬å…± API
- ä½¿ç”¨é›†æˆæµ‹è¯•éªŒè¯ç«¯åˆ°ç«¯åŠŸèƒ½
- è¿›è¡Œæ€§èƒ½åŸºå‡†æµ‹è¯•

#### 5. æ€§èƒ½è€ƒè™‘
- ä½¿ç”¨ä¸å¯å˜æ•°æ®ç»“æ„å’Œç»“æ„å…±äº«
- åˆç†ä½¿ç”¨å¼‚æ­¥ç¼–ç¨‹å’Œå¹¶å‘
- ç›‘æ§å†…å­˜ä½¿ç”¨å’Œ GC å‹åŠ›

#### 6. æ’ä»¶ä¾èµ–ç®¡ç†
- **ä½¿ç”¨ Meta è¿›è¡Œæ’ä»¶é—´é€šä¿¡**ï¼šé€šè¿‡äº‹åŠ¡ meta ä¼ é€’è½»é‡çº§çŠ¶æ€æ ‡è¯†
- **Resource Table å­˜å‚¨å¤æ‚æ•°æ®**ï¼šå°†è®¡ç®—ç»“æœç­‰å¤æ‚å¯¹è±¡å­˜å‚¨åœ¨èµ„æºè¡¨ä¸­
- **åˆç†è®¾ç½®æ’ä»¶ä¼˜å…ˆçº§**ï¼šç¡®ä¿ä¾èµ–æ’ä»¶æŒ‰æ­£ç¡®é¡ºåºæ‰§è¡Œ
- **æ˜ç¡®æ•°æ®ç”Ÿå‘½å‘¨æœŸ**ï¼šåŠæ—¶æ¸…ç†ä¸´æ—¶æ•°æ®ï¼Œé¿å…å†…å­˜æ³„æ¼
- **è®¾è®¡å›é€€æœºåˆ¶**ï¼šå½“ä¾èµ–æ•°æ®ä¸å¯ç”¨æ—¶çš„å¤„ç†ç­–ç•¥
- **æ–‡æ¡£åŒ–ä¾èµ–å…³ç³»**ï¼šæ¸…æ¥šè®°å½•æ’ä»¶é—´çš„ä¾èµ–å…³ç³»å’Œæ•°æ®æµ

## æ¶æ„ç‰¹æ€§

### ä¸å¯å˜æ•°æ®ç»“æ„
- æ‰€æœ‰çŠ¶æ€å˜æ›´éƒ½æ˜¯ä¸å¯å˜è½¬æ¢
- é«˜æ•ˆçš„ç»“æ„å…±äº«å‡å°‘å†…å­˜å¼€é”€
- é€šè¿‡ `Arc` åŒ…è£…å®ç°çº¿ç¨‹å®‰å…¨çš„å¹¶å‘è®¿é—®

### äº‹ä»¶é©±åŠ¨æ¶æ„
- æ‰€æœ‰çŠ¶æ€å˜æ›´é€šè¿‡äº‹ä»¶ç³»ç»Ÿå‘å‡º
- ç±»å‹å®‰å…¨çš„äº‹ä»¶å¤„ç†ï¼Œæ”¯æŒå¼‚æ­¥
- äº‹ä»¶æº¯æºåŠŸèƒ½ç”¨äºçŠ¶æ€é‡å»º

### æ’ä»¶ç³»ç»Ÿ
- åŠ¨æ€æ’ä»¶åŠ è½½å’Œç”Ÿå‘½å‘¨æœŸç®¡ç†
- æ’ä»¶éš”ç¦»å’Œä¾èµ–æ³¨å…¥
- æ¡†æ¶ä¸­çš„æ‰©å±•ç‚¹

### äº‹åŠ¡æ¨¡å‹
- ç¬¦åˆ ACID çš„çŠ¶æ€å˜æ›´äº‹åŠ¡
- å›æ»šåŠŸèƒ½å’Œäº‹åŠ¡æ—¥å¿—
- åŸå­æ‰¹é‡æ“ä½œ

## é”™è¯¯å¤„ç†æ¨¡å¼

```rust
use anyhow::{Result, Context};
use thiserror::Error;

// è‡ªå®šä¹‰é”™è¯¯ç±»å‹
#[derive(Error, Debug)]
pub enum AppError {
    #[error("æ–‡æ¡£æœªæ‰¾åˆ°: {id}")]
    DocumentNotFound { id: String },
    
    #[error("è§„åˆ™æ‰§è¡Œå¤±è´¥: {rule_name}")]
    RuleExecutionFailed { rule_name: String },
}

// ä½¿ç”¨ anyhow è¿›è¡Œé”™è¯¯å¤„ç†
fn process_document(doc_id: &str) -> Result<()> {
    let doc = load_document(doc_id)
        .context(format!("åŠ è½½æ–‡æ¡£å¤±è´¥: {}", doc_id))?;
    
    let result = process_rules(&doc)
        .context("è§„åˆ™å¤„ç†å¤±è´¥")?;
    
    save_result(result)
        .context("ä¿å­˜ç»“æœå¤±è´¥")?;
    
    Ok(())
}
```

## æ€§èƒ½ä¼˜åŒ–å»ºè®®

### å†…å­˜ç®¡ç†
- ä½¿ç”¨ç»“æ„å…±äº«çš„ä¸å¯å˜æ•°æ®ç»“æ„
- Arc å¼•ç”¨è®¡æ•°ç”¨äºå…±äº«æ‰€æœ‰æƒ
- LRU ç¼“å­˜ç”¨äºé¢‘ç¹è®¿é—®çš„æ•°æ®

### å¼‚æ­¥å¤„ç†
- åŸºäº Tokio çš„å¼‚æ­¥è¿è¡Œæ—¶
- åå°ä»»åŠ¡å¤„ç†
- å¤–éƒ¨èµ„æºçš„è¿æ¥æ± 

### æ‰¹é‡æ“ä½œ
- ä½¿ç”¨äº‹åŠ¡è¿›è¡Œæ‰¹é‡çŠ¶æ€æ›´æ–°
- æ‰¹é‡ç´¢å¼•æ›´æ–°
- æ‰¹é‡æ–‡ä»¶æ“ä½œ

## é›†æˆæ³¨æ„äº‹é¡¹

### å®æ—¶åä½œ
æ¡†æ¶é€šè¿‡æ˜ å°„å±‚åœ¨æ–‡æ¡£çŠ¶æ€å’Œåä½œçŠ¶æ€ä¹‹é—´æä¾›æ— ç¼é›†æˆã€‚

### è§„åˆ™å¼•æ“é›†æˆ
ä¸šåŠ¡é€»è¾‘å¯ä»¥é€šè¿‡è§„åˆ™å¼•æ“å¤–éƒ¨åŒ–ï¼Œæ”¯æŒåŠ¨æ€è§„åˆ™è¯„ä¼°è€Œæ— éœ€ä»£ç æ›´æ”¹ã€‚

### æ–‡ä»¶æ ¼å¼æ”¯æŒ
æ–‡æ¡£å¯ä»¥åºåˆ—åŒ–ä¸ºå¤šç§æ ¼å¼ï¼ˆJSONã€CBORã€MessagePackï¼‰ï¼Œæ”¯æŒå‹ç¼©ã€‚

### æœç´¢é›†æˆ
å…¨æ–‡æœç´¢åŠŸèƒ½ï¼ŒåŒ…æ‹¬ç´¢å¼•ã€æŸ¥è¯¢è§£æå’Œç»“æœæ’åã€‚

è¿™ä¸ªæ¡†æ¶ç‰¹åˆ«é€‚åˆéœ€è¦ä»¥ä¸‹åŠŸèƒ½çš„åº”ç”¨ï¼š
- å…·æœ‰åä½œåŠŸèƒ½çš„å¤æ‚æ–‡æ¡£ç¼–è¾‘
- åŠ¨æ€ä¸šåŠ¡è§„åˆ™è¯„ä¼°
- é«˜æ€§èƒ½æ•°æ®è½¬æ¢
- å¯æ‰©å±•æ’ä»¶æ¶æ„
- å®æ—¶åä½œåŠŸèƒ½

## å®Œæ•´é¡¹ç›®ç»“æ„ç¤ºä¾‹

### æ ‡å‡† Rust é¡¹ç›®ç»“æ„
```
your-project/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ CLAUDE.md
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ lib.rs
â”‚   â”œâ”€â”€ nodes/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â””â”€â”€ your_nodes.rs
â”‚   â”œâ”€â”€ marks/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â””â”€â”€ your_marks.rs
â”‚   â”œâ”€â”€ middleware/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â””â”€â”€ your_middleware.rs
â”‚   â”œâ”€â”€ plugins/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â””â”€â”€ your_plugin.rs
â”‚   â”œâ”€â”€ editor/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â””â”€â”€ editor_config.rs
â”‚   â””â”€â”€ types.rs
â””â”€â”€ examples/
    â””â”€â”€ basic_usage.rs
```

### Tauri æ¡Œé¢åº”ç”¨é¡¹ç›®ç»“æ„
```
your-tauri-app/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ CLAUDE.md
â”œâ”€â”€ tauri.conf.json
â”œâ”€â”€ build.rs
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ lib.rs
â”‚   â”œâ”€â”€ commands/          # Tauri å‘½ä»¤
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â””â”€â”€ editor.rs
â”‚   â”œâ”€â”€ nodes/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â””â”€â”€ your_nodes.rs
â”‚   â”œâ”€â”€ marks/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â””â”€â”€ your_marks.rs
â”‚   â”œâ”€â”€ middleware/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â””â”€â”€ your_middleware.rs
â”‚   â”œâ”€â”€ plugins/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â””â”€â”€ your_plugin.rs
â”‚   â”œâ”€â”€ editor/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â””â”€â”€ editor_config.rs
â”‚   â””â”€â”€ types.rs
â”œâ”€â”€ src-ui/               # å‰ç«¯ä»£ç 
â”‚   â”œâ”€â”€ package.json
â”‚   â”œâ”€â”€ index.html
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ main.ts
â”‚   â”‚   â”œâ”€â”€ App.vue
â”‚   â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”‚   â””â”€â”€ editor.ts
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”œâ”€â”€ Editor.vue
â”‚   â”‚   â”‚   â””â”€â”€ NodeTree.vue
â”‚   â”‚   â””â”€â”€ stores/
â”‚   â”‚       â””â”€â”€ editor.ts
â”‚   â””â”€â”€ dist/             # æ„å»ºè¾“å‡º
â””â”€â”€ icons/                # åº”ç”¨å›¾æ ‡
    â”œâ”€â”€ 32x32.png
    â”œâ”€â”€ 128x128.png
    â”œâ”€â”€ icon.icns
    â””â”€â”€ icon.ico
```

### lib.rs
```rust
pub mod nodes;
pub mod marks;
pub mod middleware;
pub mod plugins;
pub mod editor;
pub mod types;

// é‡æ–°å¯¼å‡ºå¸¸ç”¨ç±»å‹
pub use mf_core::*;
pub use mf_model::*;
pub use mf_state::*;
pub use mf_transform::*;
pub use editor::{MyEditor, MyEditorOptions, init_editor, init_options};
```

### main.rs
```rust
use anyhow::Result;
use your_project::{init_editor, init_options};
use std::sync::Arc;
use mf_core::types::NodePoolFnTrait;

// å®šä¹‰ä¸€ä¸ªç®€å•çš„èŠ‚ç‚¹æ± åˆ›å»ºå‡½æ•°
struct SimpleNodePoolFn;

impl NodePoolFnTrait for SimpleNodePoolFn {
    fn call(&self) -> mf_model::node_pool::NodePool {
        mf_model::node_pool::NodePool::default()
    }
}

#[tokio::main]
async fn main() -> Result<()> {
    // åˆå§‹åŒ–æ—¥å¿—
    tracing_subscriber::fmt::init();
    
    // åˆ›å»ºèŠ‚ç‚¹æ± å›è°ƒ
    let create_callback: Arc<dyn NodePoolFnTrait> = Arc::new(SimpleNodePoolFn);
    
    // è·å–ç¼–è¾‘å™¨é…ç½®
    let options = init_options(create_callback).await;
    
    // åˆ›å»ºç¼–è¾‘å™¨
    let mut editor = init_editor(options).await;
    
    // è·å–å½“å‰çŠ¶æ€
    let state = editor.get_state().await;
    println!("ç¼–è¾‘å™¨åˆ›å»ºæˆåŠŸï¼Œæ–‡æ¡£ ID: {}", state.id());
    
    // åœ¨è¿™é‡Œæ·»åŠ ä½ çš„åº”ç”¨é€»è¾‘
    
    Ok(())
}
```

## å¿«é€Ÿå¯åŠ¨æ¨¡æ¿

```rust
use mf_core::{
    runtime::async_runtime::ForgeAsyncRuntime,
    types::{RuntimeOptions, EditorOptionsBuilder, Content, NodePoolFnTrait}
};
use mf_model::node_pool::NodePool;
use anyhow::Result;
use std::sync::Arc;

// ç®€å•çš„èŠ‚ç‚¹æ± åˆ›å»ºå‡½æ•°
struct DefaultNodePoolFn;

impl NodePoolFnTrait for DefaultNodePoolFn {
    fn call(&self) -> NodePool {
        NodePool::default()
    }
}

#[tokio::main]
async fn main() -> Result<()> {
    // åˆå§‹åŒ–æ—¥å¿—
    tracing_subscriber::fmt::init();
    
    // åˆ›å»ºç¼–è¾‘å™¨é…ç½®
    let create_callback: Arc<dyn NodePoolFnTrait> = Arc::new(DefaultNodePoolFn);
    let mut builder = EditorOptionsBuilder::new();
    builder = builder
        .content(Content::NodePoolFn(create_callback))
        .history_limit(20);
    
    let options = builder.build();
    
    // åˆ›å»ºè¿è¡Œæ—¶
    let runtime = ForgeAsyncRuntime::create(options).await?;
    
    // è·å–å½“å‰çŠ¶æ€
    let state = runtime.get_state();
    println!("ModuForge-RS åº”ç”¨å¯åŠ¨æˆåŠŸï¼æ–‡æ¡£ ID: {}", state.id());
    
    // ä½ çš„åº”ç”¨é€»è¾‘
    
    Ok(())
}
```