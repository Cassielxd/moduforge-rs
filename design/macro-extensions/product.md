# 产品愿景定义 - ModuForge-RS 宏模块扩展

## 产品愿景

基于 ModuForge-RS 框架，为开发者提供声明式的宏系统，自动化生成 `mf-core::Node` 和 `mf-core::Mark` 实例的样板代码。通过编译时代码生成，显著提升开发效率，减少重复代码，增强类型安全性。

## 核心目标

### 主要目标
1. **简化 Node 和 Mark 定义**：通过声明式宏属性，自动生成复杂的 Node 和 Mark 构造代码
2. **减少样板代码**：消除手动创建 `mf_core::node::Node` 和 `mf_core::mark::Mark` 的重复劳动
3. **编译时验证**：在编译阶段验证节点类型、属性和内容约束的正确性
4. **类型安全增强**：确保生成的代码符合 ModuForge-RS 框架的类型系统要求

### 次要目标
1. **开发体验优化**：提供直观的 API 和清晰的错误提示
2. **文档自动生成**：为生成的方法自动添加详细的中文文档注释
3. **IDE 集成支持**：确保生成的代码能被 IDE 正确识别和补全
4. **扩展性保障**：为未来的宏功能扩展预留接口

## 用户画像

### 目标用户群体
- **ModuForge-RS 应用开发者**：使用框架构建业务应用的 Rust 开发者
- **框架集成者**：将 ModuForge-RS 集成到现有系统的技术团队
- **插件开发者**：为 ModuForge-RS 生态开发插件的开发者

### 使用场景
1. **业务模型定义**：快速定义文档结构和业务实体
2. **插件开发**：创建自定义的节点类型和标记类型
3. **原型开发**：快速构建应用原型和验证概念
4. **大型项目维护**：在复杂项目中保持代码一致性和可维护性

### 用户需求分析
- **便捷性**：希望用最少的代码表达完整的节点定义
- **正确性**：需要编译时验证确保代码的正确性
- **可读性**：生成的代码应该清晰易懂
- **性能**：生成的代码应该具有良好的运行时性能

## 功能概述

### 核心功能模块

#### 1. Node 宏功能
```rust
#[derive(Node, Serialize, Deserialize)]
#[node_type = "GCXM", marks="color", content="DCXM"]
pub struct ConstructProject {
    #[attr]
    name: String,
    #[attr]
    age: Option<i32>
}
```
- 自动生成 `to_node()` 方法，返回 `mf_core::node::Node`
- 处理 `node_type`、`marks`、`content` 属性配置
- 识别 `#[attr]` 标注的字段，自动映射为节点属性

#### 2. Mark 宏功能
```rust
#[derive(Mark, Serialize, Deserialize)]
#[mark_type = "color"]
pub struct Color {
    #[attr]
    name: String,
    #[attr]
    intensity: Option<f32>
}
```
- 自动生成 `to_mark()` 方法，返回 `mf_core::mark::Mark`
- 处理 `mark_type` 属性配置
- 自动属性映射和类型转换

#### 3. 属性处理系统
- 支持基本 Rust 类型到 `serde_json::Value` 的自动转换
- 处理 `Option<T>` 类型的可选属性
- 提供自定义属性转换接口

#### 4. 验证和错误处理
- 编译时验证宏属性的合法性
- 提供清晰的错误消息和修复建议
- 类型兼容性检查

## 业务流程概述

### 开发流程
1. **结构体定义**：开发者定义业务结构体并添加宏属性
2. **编译时处理**：宏系统解析属性，生成对应的方法
3. **代码生成**：自动生成 `to_node()` 和 `to_mark()` 方法
4. **运行时使用**：调用生成的方法创建 ModuForge-RS 实例

### 集成流程
1. **依赖添加**：项目中添加 mf-derive crate 依赖
2. **导入宏**：使用 `use mf_derive::{Node, Mark}` 导入宏
3. **应用宏**：在结构体上应用对应的宏
4. **调用方法**：使用生成的方法创建 Node 和 Mark 实例

## 成功指标

### 功能指标
- **代码减少率**：相比手动实现，样板代码减少 80% 以上
- **编译时检测覆盖率**：覆盖 95% 以上的常见配置错误
- **类型安全性**：100% 的生成代码通过类型检查
- **API 一致性**：生成的 API 与手写代码保持 100% 兼容

### 性能指标
- **编译时间**：宏处理时间不超过基础编译时间的 10%
- **运行时性能**：生成代码性能与手写代码相当
- **内存占用**：不引入额外的运行时内存开销

### 用户体验指标
- **学习成本**：新用户在 30 分钟内掌握基本用法
- **错误提示质量**：90% 的编译错误能提供明确的解决方案
- **文档完整性**：所有公开 API 都有完整的中文文档

### 生态系统指标
- **兼容性**：与现有 ModuForge-RS 生态 100% 兼容
- **扩展性**：支持第三方插件和自定义转换器
- **维护性**：代码变更对用户 API 影响最小化

## 价值主张

1. **开发效率提升**：大幅减少样板代码编写时间
2. **代码质量保障**：编译时验证减少运行时错误
3. **学习成本降低**：声明式语法更直观易懂
4. **维护成本减少**：自动生成的代码减少维护负担
5. **框架生态完善**：为 ModuForge-RS 提供更好的开发体验

通过这个宏模块扩展，ModuForge-RS 将成为一个更加开发者友好的框架，显著提升基于该框架的应用开发效率和代码质量。